{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Emanuel Trandafir Hey there, I'm Emanuel - a Software Craftsman from Romania. I value simplicity and intentionality over blindly applying patterns and abstractions. I care deeply about the design and testability of the software I create. I also value communication and collaboration and enjoy sharing my knowledge through open-source contributions and technical articles. #design #functional programming #testing #books Less Mocks, More Functions! Clojure Threading for Dummy Java Devs (such as myself) Less Mocks, More Functions! Less Mocks, More Functions! 'Tidy First?' and my Post-Reading Commitments let currentActive = null; function showArticles(tag) { const articleDiv = document.getElementById(tag + '-articles'); const buttons = document.querySelectorAll('.tag-chip'); // If clicking the same tag, close it if (currentActive === articleDiv) { articleDiv.classList.remove('active'); buttons.forEach(btn => btn.classList.remove('active')); currentActive = null; return; } // Hide all article containers and remove active state from buttons document.querySelectorAll('.articles-container').forEach(div => { div.classList.remove('active'); }); buttons.forEach(btn => btn.classList.remove('active')); // Show selected articles and highlight button articleDiv.classList.add('active'); event.target.classList.add('active'); currentActive = articleDiv; }","title":"--- About Me ---"},{"location":"#emanuel-trandafir","text":"Hey there, I'm Emanuel - a Software Craftsman from Romania. I value simplicity and intentionality over blindly applying patterns and abstractions. I care deeply about the design and testability of the software I create. I also value communication and collaboration and enjoy sharing my knowledge through open-source contributions and technical articles. #design #functional programming #testing #books Less Mocks, More Functions! Clojure Threading for Dummy Java Devs (such as myself) Less Mocks, More Functions! Less Mocks, More Functions! 'Tidy First?' and my Post-Reading Commitments let currentActive = null; function showArticles(tag) { const articleDiv = document.getElementById(tag + '-articles'); const buttons = document.querySelectorAll('.tag-chip'); // If clicking the same tag, close it if (currentActive === articleDiv) { articleDiv.classList.remove('active'); buttons.forEach(btn => btn.classList.remove('active')); currentActive = null; return; } // Hide all article containers and remove active state from buttons document.querySelectorAll('.articles-container').forEach(div => { div.classList.remove('active'); }); buttons.forEach(btn => btn.classList.remove('active')); // Show selected articles and highlight button articleDiv.classList.add('active'); event.target.classList.add('active'); currentActive = articleDiv; }","title":"Emanuel Trandafir"},{"location":"blog/clojure-threading/","text":"Clojure Threading for Dummy Java Devs (such as myself) Published: August 30, 2025 #clojure #java #functional programming Recently, I've been playing around with Clojure. I wanted to take advantage of the AI tools available to explore a new language... and not just Kotlin or Python, but something completely new to me. One of the features that caught my attention was the threading macros ( -> and ->> ) it's a pretty simple feature, but I found it interesting and elegant. Strava Heatmaps A few words about the project I've built in Clojure? Well, I'm recording all my sport activities using my Garmin watch, even when I'm playing football. When I get home and download my activity, the map looks something like the spaghetti code I generate when vibe-coding with ChatGPT: Needless to say, I want to visualize my football session a bit better. so I decided to build a small app to export this activity as a GPX file and generate an HTML heatmap based on it. After applying all these steps, we'll expect a heatmap like this: Basically, we need to: parse the GPX file (GPX is an XML schema designed as a common GPS data) normalize the data (optionally) rotate the activity by a given angle (optionally) filter the data - for eg.: by running cadence generate the heatmap generate the HTML file A functional language sounded like a perfect fit for implementing this pipeline of operations, so I decided to give Clojure a try. Before diving into the threading macros that make these pipelines so elegant, let's cover some Clojure basics. If you're coming from Java like me, the syntax might look intimidating at first, but the core concepts are actually quite straightforward once you get the hang of the parentheses. Clojure Syntax Let me show you what I understood about Clojure so far. The syntax follows a consistent pattern: (function-name arguments...) where the function always comes first inside the parentheses, followed by its arguments. For example, if we want to add two numbers (say 1 and 2) , we would write: ( + 1 2 ) . This is because + is the addition function, followed by 1 and 2 - the numbers being added. We can define a function using the defn keyword, followed by the function name, its arguments, and the body of the function. Let's write a function that adds two numbers, received as arguments: (defn add [a b] (+ a b)) Similarly, when we want to compare numbers, we'll start with the comparison function, followed by the numbers to compare. For instance, this is how we verify if two numbers (a and b) are equal: ( = a b ) Now let's write a unit test for our add function: (deftest add-two-test (is (= 3 (add 1 2) ) ) ) ;; or simply: (deftest add-two-test (is (= 3 (add 1 2)))) The Threading Macros Look at our test: as simple as it is, it already has quite a few nested function calls. If we read it from right to left, we can see that we're: adding 1 and 2 comparing the result with 3 verifying if the result is true When it comes to pipelines of operations, the threading macros ( -> and ->> ) allows us to take the result of one operation and pass it as argument to the next operation. The difference between the two is that -> ( aka thread-first ) passes the value to the next function as the first argument, while ->> ( aka thread-last ) passes the value as the last argument. Therefore, we can re-write our test as follows: (deftest add-two-test-x (->> 1 (add 2) (= 3) (is))) And it reads like this: we start with the number 1, then we add 2 to it, then we compare the result with 3, and finally we verify if the new result is true. Of course, this is a very simple example, but it shows the power of the threading macros. Let's go back to our heatmap pipeline: As discussed, we'll start with a GPX file that we need to read as text. Then, we'll parse its content and normalize the data. At this point, we can optionally rotate the activity by a given angle and/or filter the data. Then, we'll generate the heatmap as a sparse matrix. Following that, we'll convert the matrix to RGB values, convert it to json and inject it into a HTML template. Quite a few nested function calls, right? Wait to see them in action: (defn strava-heatmap [file] (html/save-file (html/generate-html (heatmap/map-to-json (heatmap/map-to-rgb (heatmap/heatmap-matrix (heatmap/normalize-trkpts (gpx/xml-to-trkpts (gpx/read-file-as-string file))))))) (str \"out/\" (UUID/randomUUID) \".html\"))) Now, let's re-write it using the threading macros: we'll start from the GPX file we exported from Strava and thread the result of each step as the last argument of the next function: (defn strava-heatmap [file] (->> file gpx/read-file-as-string gpx/xml-to-trkpts heatmap/normalize-trkpts heatmap/heatmap-matrix heatmap/map-to-rgb heatmap/map-to-json html/generate-html (html/save-file (str \"out/\" (UUID/randomUUID) \".html\")))) Pretty neat, isn't it? Let's add a step to rotate the activity counter-clockwise by 55 degrees, because I want the heatmap to be aligned with the pitch of the field, rather than the North-South axis. Additionally, let's remove the track points with a cadence of less than 10 steps per minute (filtering out epic failures as a goalkeeper): (defn strava-heatmap [file] (->> file gpx/read-file-as-string gpx/xml-to-trkpts (filter (fn[pt] (> (:cadence pt) 10))) ;; <- filter by cadence heatmap/normalize-trkpts-precision (heatmap/rotate-points -55) ;; <- rotate counter-clockwise by 55 degrees heatmap/heatmap-matrix heatmap/map-to-rgb heatmap/map-to-json html/generate-html (html/save-file (str \"out/\" (UUID/randomUUID) \".html\")))) As we can see, it's much easier to add new steps to the pipeline. I also like the fact that you don't really need to know Clojure to be able to read this flow. Beyond readability, functional pipelines offer significant practical benefits: each transformation step is isolated and testable, making debugging easier since we can inspect the output at any stage. Additionally, pipeline steps can be easily reordered, combined, or parallelized without affecting other parts of the system. What About Java? What does this remind you of from Java? And why the Stream API? Some fluent APIs from Java are inspired from functional programming. That's why we can find similar patterns in the Stream API, reactive pipelines... and even CompletableFuture! Jus for fun, let's imagine we wrote this in Java, using the CompletableFuture API (this is how the code can look like): public CompletableFuture<Path> stravaHeatmap(String file) { return CompletableFuture .supplyAsync(() -> gpx.readFileAsString(file)) .thenApply(xml -> gpx.xmlToTrkpts(xml)) .thenApply(pts -> pts.stream() .filter(pt -> pt.cadence() > 10).toList()) .thenApply(pts -> heatmap.normalizeTrkptsPrecision(pts)) .thenApply(pts -> heatmap.rotatePoints(pts, -55)) .thenApply(map -> heatmap.heatmapMatrix(map)) .thenApply(map -> heatmap.mapToRgb(map)) .thenApply(rgb -> heatmap.mapToJson(rgb)) .thenApply(json -> htmlUtil.generateHtml(json)) .thenApply(html -> htmlUtil.saveFile( \"out/%s.html\".frormatted(UUID.randomUUID())), html); } Needless to say, the Clojure version is much easier to read and reason about. The threading pattern we see in Clojure aligns perfectly with Data-Oriented Programming (DOP), a paradigm gaining traction in Java. DOP emphasizes treating data as immutable and flowing it through a series of transformations, rather than encapsulating it within objects. This approach naturally benefits from threading operators because data transformations become explicit pipeline steps. If you want to read more about DOP, check out this article Conclusion In this shoer article, we discussed Clojure's threading macros. One of those simple features that make a huge difference in how you write and think about code. Whether you're working in Clojure or dreaming of better Java syntax, the pattern is worth understanding. Do you think we'll ever get a threading operator in Java?","title":"Clojure Threading for Dummy Java Devs (such as myself)"},{"location":"blog/clojure-threading/#clojure-threading-for-dummy-java-devs-such-as-myself","text":"Published: August 30, 2025 #clojure #java #functional programming Recently, I've been playing around with Clojure. I wanted to take advantage of the AI tools available to explore a new language... and not just Kotlin or Python, but something completely new to me. One of the features that caught my attention was the threading macros ( -> and ->> ) it's a pretty simple feature, but I found it interesting and elegant.","title":"Clojure Threading for Dummy Java Devs (such as myself)"},{"location":"blog/clojure-threading/#strava-heatmaps","text":"A few words about the project I've built in Clojure? Well, I'm recording all my sport activities using my Garmin watch, even when I'm playing football. When I get home and download my activity, the map looks something like the spaghetti code I generate when vibe-coding with ChatGPT: Needless to say, I want to visualize my football session a bit better. so I decided to build a small app to export this activity as a GPX file and generate an HTML heatmap based on it. After applying all these steps, we'll expect a heatmap like this: Basically, we need to: parse the GPX file (GPX is an XML schema designed as a common GPS data) normalize the data (optionally) rotate the activity by a given angle (optionally) filter the data - for eg.: by running cadence generate the heatmap generate the HTML file A functional language sounded like a perfect fit for implementing this pipeline of operations, so I decided to give Clojure a try. Before diving into the threading macros that make these pipelines so elegant, let's cover some Clojure basics. If you're coming from Java like me, the syntax might look intimidating at first, but the core concepts are actually quite straightforward once you get the hang of the parentheses.","title":"Strava Heatmaps"},{"location":"blog/clojure-threading/#clojure-syntax","text":"Let me show you what I understood about Clojure so far. The syntax follows a consistent pattern: (function-name arguments...) where the function always comes first inside the parentheses, followed by its arguments. For example, if we want to add two numbers (say 1 and 2) , we would write: ( + 1 2 ) . This is because + is the addition function, followed by 1 and 2 - the numbers being added. We can define a function using the defn keyword, followed by the function name, its arguments, and the body of the function. Let's write a function that adds two numbers, received as arguments: (defn add [a b] (+ a b)) Similarly, when we want to compare numbers, we'll start with the comparison function, followed by the numbers to compare. For instance, this is how we verify if two numbers (a and b) are equal: ( = a b ) Now let's write a unit test for our add function: (deftest add-two-test (is (= 3 (add 1 2) ) ) ) ;; or simply: (deftest add-two-test (is (= 3 (add 1 2))))","title":"Clojure Syntax"},{"location":"blog/clojure-threading/#the-threading-macros","text":"Look at our test: as simple as it is, it already has quite a few nested function calls. If we read it from right to left, we can see that we're: adding 1 and 2 comparing the result with 3 verifying if the result is true When it comes to pipelines of operations, the threading macros ( -> and ->> ) allows us to take the result of one operation and pass it as argument to the next operation. The difference between the two is that -> ( aka thread-first ) passes the value to the next function as the first argument, while ->> ( aka thread-last ) passes the value as the last argument. Therefore, we can re-write our test as follows: (deftest add-two-test-x (->> 1 (add 2) (= 3) (is))) And it reads like this: we start with the number 1, then we add 2 to it, then we compare the result with 3, and finally we verify if the new result is true. Of course, this is a very simple example, but it shows the power of the threading macros. Let's go back to our heatmap pipeline: As discussed, we'll start with a GPX file that we need to read as text. Then, we'll parse its content and normalize the data. At this point, we can optionally rotate the activity by a given angle and/or filter the data. Then, we'll generate the heatmap as a sparse matrix. Following that, we'll convert the matrix to RGB values, convert it to json and inject it into a HTML template. Quite a few nested function calls, right? Wait to see them in action: (defn strava-heatmap [file] (html/save-file (html/generate-html (heatmap/map-to-json (heatmap/map-to-rgb (heatmap/heatmap-matrix (heatmap/normalize-trkpts (gpx/xml-to-trkpts (gpx/read-file-as-string file))))))) (str \"out/\" (UUID/randomUUID) \".html\"))) Now, let's re-write it using the threading macros: we'll start from the GPX file we exported from Strava and thread the result of each step as the last argument of the next function: (defn strava-heatmap [file] (->> file gpx/read-file-as-string gpx/xml-to-trkpts heatmap/normalize-trkpts heatmap/heatmap-matrix heatmap/map-to-rgb heatmap/map-to-json html/generate-html (html/save-file (str \"out/\" (UUID/randomUUID) \".html\")))) Pretty neat, isn't it? Let's add a step to rotate the activity counter-clockwise by 55 degrees, because I want the heatmap to be aligned with the pitch of the field, rather than the North-South axis. Additionally, let's remove the track points with a cadence of less than 10 steps per minute (filtering out epic failures as a goalkeeper): (defn strava-heatmap [file] (->> file gpx/read-file-as-string gpx/xml-to-trkpts (filter (fn[pt] (> (:cadence pt) 10))) ;; <- filter by cadence heatmap/normalize-trkpts-precision (heatmap/rotate-points -55) ;; <- rotate counter-clockwise by 55 degrees heatmap/heatmap-matrix heatmap/map-to-rgb heatmap/map-to-json html/generate-html (html/save-file (str \"out/\" (UUID/randomUUID) \".html\")))) As we can see, it's much easier to add new steps to the pipeline. I also like the fact that you don't really need to know Clojure to be able to read this flow. Beyond readability, functional pipelines offer significant practical benefits: each transformation step is isolated and testable, making debugging easier since we can inspect the output at any stage. Additionally, pipeline steps can be easily reordered, combined, or parallelized without affecting other parts of the system.","title":"The Threading Macros"},{"location":"blog/clojure-threading/#what-about-java","text":"What does this remind you of from Java? And why the Stream API? Some fluent APIs from Java are inspired from functional programming. That's why we can find similar patterns in the Stream API, reactive pipelines... and even CompletableFuture! Jus for fun, let's imagine we wrote this in Java, using the CompletableFuture API (this is how the code can look like): public CompletableFuture<Path> stravaHeatmap(String file) { return CompletableFuture .supplyAsync(() -> gpx.readFileAsString(file)) .thenApply(xml -> gpx.xmlToTrkpts(xml)) .thenApply(pts -> pts.stream() .filter(pt -> pt.cadence() > 10).toList()) .thenApply(pts -> heatmap.normalizeTrkptsPrecision(pts)) .thenApply(pts -> heatmap.rotatePoints(pts, -55)) .thenApply(map -> heatmap.heatmapMatrix(map)) .thenApply(map -> heatmap.mapToRgb(map)) .thenApply(rgb -> heatmap.mapToJson(rgb)) .thenApply(json -> htmlUtil.generateHtml(json)) .thenApply(html -> htmlUtil.saveFile( \"out/%s.html\".frormatted(UUID.randomUUID())), html); } Needless to say, the Clojure version is much easier to read and reason about. The threading pattern we see in Clojure aligns perfectly with Data-Oriented Programming (DOP), a paradigm gaining traction in Java. DOP emphasizes treating data as immutable and flowing it through a series of transformations, rather than encapsulating it within objects. This approach naturally benefits from threading operators because data transformations become explicit pipeline steps. If you want to read more about DOP, check out this article","title":"What About Java?"},{"location":"blog/clojure-threading/#conclusion","text":"In this shoer article, we discussed Clojure's threading macros. One of those simple features that make a huge difference in how you write and think about code. Whether you're working in Clojure or dreaming of better Java syntax, the pattern is worth understanding. Do you think we'll ever get a threading operator in Java?","title":"Conclusion"},{"location":"blog/less-mocks-more-functions/","text":"Less Mocks, More Functions! Published: September 28, 2025 #functional programming #design #testing #java After playing with Clojure , I was amazed by how testable everything is in the functional world. In this article, we'll explore a technique that uses functional interfaces to reduce the number of mocks needed for testing. I started thinking about incorporating some functional techniques into my Java development work - without shaking up the codebase too much or becoming \"that functional programming person\" colleagues avoid at the water cooler. The main idea is simple: extract dependencies that produce side effects and move them outside of the component you want to test . The Problem This technique is particularly effective when the tested component relies on a dependency but utilizes only a select few of its methods, ideally just one. We'll use Java for the code examples in the article, but the approach can be applied regardless of the language or testing frameworks. Let's start with a typical example: class AccountService { private final AccountRepository repository; AccountService(AccountRepository repository) { this.repository = repository; } void register(String name, String email) { var uuid = UUID.randomUUID(); var account = new Account(uuid.toString(), name, email); // some business logic repository.save(account); } } To test this without connecting to a database, we need to mock the repository: @Test void testWithMocks() { var repository = mock(AccountRepository.class); var service = new AccountService(repository); service.register(\"john doe\", \"jd@yahoo.com\"); verify(repository).save(argThat(it -> it.name().equals(\"john doe\") && it.email().equals(\"jd@yahoo.com\") && it.id() != null )); } Using Functions for Side Effects If we think about it, we only need a mock because AccountService::register produces side effects (saving the Account into the database). Another obvious problem with our design is that we depend on the whole AccountRepository class even though we only use its save() method. Simply put, our class needs a function that accepts an Account and saves it. The signature of this function would be (Account) -> void . In Java, this function is also known as Consumer<Account> . So, let's change AccountService and make it depend on this function instead of holding the whole repository: class AccountService { private final Consumer<Account> saveAccount; AccountService(Consumer<Account> saveAccount) { this.saveAccount = saveAccount; } // Maintain backwards compatibility @Autowired AccountService(AccountRepository repository) { this(repository::save); } void register(String name, String email) { var uuid = UUID.randomUUID(); var account = new Account(uuid.toString(), name, email); // some business logic saveAccount.accept(account); } } Testing Becomes Fun Now testing becomes much simpler: @Test void testWithLambdas() { List<Account> savedAccounts = new ArrayList<>(); var service = new AccountService(savedAccounts::add); service.register(\"john doe\", \"jd@yahoo.com\"); assertThat(savedAccounts) .hasSize(1).first() .hasFieldOrPropertyWithValue(\"name\", \"john doe\") .hasFieldOrPropertyWithValue(\"email\", \"jd@yahoo.com\") .hasFieldOrProperty(\"id\"); } Testing exceptions is equally straightforward: @Test void testWithLambdas_exceptions() { var service = new AccountService(__ -> { throw new IllegalArgumentException(\"test exception\"); }); assertThatThrownBy(() -> service.register(\"john doe\", \"jd@yahoo.com\")) .isInstanceOf(IllegalArgumentException.class); } Handling Static Dependencies Our code still isn't \"pure\" because it calls UUID.randomUUID() . We can apply the same technique here by extracting the UUID generation: class AccountService { private final Consumer<Account> saveAccount; private final Supplier<UUID> generateUuid; AccountService(Consumer<Account> saveAccount, Supplier<UUID> generateUuid) { this.saveAccount = saveAccount; this.generateUuid = generateUuid; } // Backwards compatibility @Autowired AccountService(AccountRepository repository) { this(repository::save, UUID::randomUUID); } void register(String name, String email) { var uuid = generateUuid.get(); var account = new Account(uuid.toString(), name, email); // some business logic saveAccount.accept(account); } } Now our tests are completely deterministic: @Test void testWithLambdas() { List<Account> savedAccounts = new ArrayList<>(); var service = new AccountService( savedAccounts::add, () -> UUID.fromString(\"00000000-0000-0000-0000-000000000001\") ); service.register(\"john doe\", \"jd@yahoo.com\"); assertThat(savedAccounts) .hasSize(1).first() .hasFieldOrPropertyWithValue(\"name\", \"john doe\") .hasFieldOrPropertyWithValue(\"email\", \"jd@yahoo.com\") .hasFieldOrPropertyWithValue(\"id\", \"00000000-0000-0000-0000-000000000001\"); } Conclusion By extracting side effects into functions, we've made our code: \u2705 Easier to test - no mocks needed \u2705 More focused - our components only depends on what it actually needs \u2705 Backwards compatible - existing code continues to work This technique aligns with SOLID principles (specifically Interface Segregation and Dependency Inversion) while borrowing useful concepts from functional programming. The result is cleaner, more testable code that's easier to reason about.","title":"Less Mocks, More Functions!"},{"location":"blog/less-mocks-more-functions/#less-mocks-more-functions","text":"Published: September 28, 2025 #functional programming #design #testing #java After playing with Clojure , I was amazed by how testable everything is in the functional world. In this article, we'll explore a technique that uses functional interfaces to reduce the number of mocks needed for testing. I started thinking about incorporating some functional techniques into my Java development work - without shaking up the codebase too much or becoming \"that functional programming person\" colleagues avoid at the water cooler. The main idea is simple: extract dependencies that produce side effects and move them outside of the component you want to test .","title":"Less Mocks, More Functions!"},{"location":"blog/less-mocks-more-functions/#the-problem","text":"This technique is particularly effective when the tested component relies on a dependency but utilizes only a select few of its methods, ideally just one. We'll use Java for the code examples in the article, but the approach can be applied regardless of the language or testing frameworks. Let's start with a typical example: class AccountService { private final AccountRepository repository; AccountService(AccountRepository repository) { this.repository = repository; } void register(String name, String email) { var uuid = UUID.randomUUID(); var account = new Account(uuid.toString(), name, email); // some business logic repository.save(account); } } To test this without connecting to a database, we need to mock the repository: @Test void testWithMocks() { var repository = mock(AccountRepository.class); var service = new AccountService(repository); service.register(\"john doe\", \"jd@yahoo.com\"); verify(repository).save(argThat(it -> it.name().equals(\"john doe\") && it.email().equals(\"jd@yahoo.com\") && it.id() != null )); }","title":"The Problem"},{"location":"blog/less-mocks-more-functions/#using-functions-for-side-effects","text":"If we think about it, we only need a mock because AccountService::register produces side effects (saving the Account into the database). Another obvious problem with our design is that we depend on the whole AccountRepository class even though we only use its save() method. Simply put, our class needs a function that accepts an Account and saves it. The signature of this function would be (Account) -> void . In Java, this function is also known as Consumer<Account> . So, let's change AccountService and make it depend on this function instead of holding the whole repository: class AccountService { private final Consumer<Account> saveAccount; AccountService(Consumer<Account> saveAccount) { this.saveAccount = saveAccount; } // Maintain backwards compatibility @Autowired AccountService(AccountRepository repository) { this(repository::save); } void register(String name, String email) { var uuid = UUID.randomUUID(); var account = new Account(uuid.toString(), name, email); // some business logic saveAccount.accept(account); } }","title":"Using Functions for Side Effects"},{"location":"blog/less-mocks-more-functions/#testing-becomes-fun","text":"Now testing becomes much simpler: @Test void testWithLambdas() { List<Account> savedAccounts = new ArrayList<>(); var service = new AccountService(savedAccounts::add); service.register(\"john doe\", \"jd@yahoo.com\"); assertThat(savedAccounts) .hasSize(1).first() .hasFieldOrPropertyWithValue(\"name\", \"john doe\") .hasFieldOrPropertyWithValue(\"email\", \"jd@yahoo.com\") .hasFieldOrProperty(\"id\"); } Testing exceptions is equally straightforward: @Test void testWithLambdas_exceptions() { var service = new AccountService(__ -> { throw new IllegalArgumentException(\"test exception\"); }); assertThatThrownBy(() -> service.register(\"john doe\", \"jd@yahoo.com\")) .isInstanceOf(IllegalArgumentException.class); }","title":"Testing Becomes Fun"},{"location":"blog/less-mocks-more-functions/#handling-static-dependencies","text":"Our code still isn't \"pure\" because it calls UUID.randomUUID() . We can apply the same technique here by extracting the UUID generation: class AccountService { private final Consumer<Account> saveAccount; private final Supplier<UUID> generateUuid; AccountService(Consumer<Account> saveAccount, Supplier<UUID> generateUuid) { this.saveAccount = saveAccount; this.generateUuid = generateUuid; } // Backwards compatibility @Autowired AccountService(AccountRepository repository) { this(repository::save, UUID::randomUUID); } void register(String name, String email) { var uuid = generateUuid.get(); var account = new Account(uuid.toString(), name, email); // some business logic saveAccount.accept(account); } } Now our tests are completely deterministic: @Test void testWithLambdas() { List<Account> savedAccounts = new ArrayList<>(); var service = new AccountService( savedAccounts::add, () -> UUID.fromString(\"00000000-0000-0000-0000-000000000001\") ); service.register(\"john doe\", \"jd@yahoo.com\"); assertThat(savedAccounts) .hasSize(1).first() .hasFieldOrPropertyWithValue(\"name\", \"john doe\") .hasFieldOrPropertyWithValue(\"email\", \"jd@yahoo.com\") .hasFieldOrPropertyWithValue(\"id\", \"00000000-0000-0000-0000-000000000001\"); }","title":"Handling Static Dependencies"},{"location":"blog/less-mocks-more-functions/#conclusion","text":"By extracting side effects into functions, we've made our code: \u2705 Easier to test - no mocks needed \u2705 More focused - our components only depends on what it actually needs \u2705 Backwards compatible - existing code continues to work This technique aligns with SOLID principles (specifically Interface Segregation and Dependency Inversion) while borrowing useful concepts from functional programming. The result is cleaner, more testable code that's easier to reason about.","title":"Conclusion"},{"location":"blog/tidy-first-commitments/","text":"'Tidy First?' and my Post-Reading Commitments Published: April 11, 2024 #software design #books You know that good feeling when you come across a piece of code that's concise and cohesive? The code that allows you to focus on its purpose, and it doesn't have logic scattered all over the place? That's the same feeling I've got reading Kent Beck's \"Tidy First?\" . It's a remarkably succinct book, spanning just 100 pages, divided into three sections, each comprised of a handful of brief chapters. Some chapters are no longer than a single page, yet they're incredibly rich in content. At times, I found myself revisiting certain chapters to fully absorb their insights. Small Improvements with Big Impact The first section of the book explains what \"tidyings\" are, and provides some practical examples for 15 of these small improvements. In essence, we can think of \"tidyings\" as the younger relatives of \"refactorings\". Some tidyings can be as simple as extracting explanatory variables and helper functions. You'll probably be familiar with these techniques, and your IDE should already have shortcuts for pretty much all of them. However, reading through this section will give you a feeling of the size and granularity of these changes. This will help you better understand the second section about rhythm and pace. Long story short, the concept of \"refactoring\" got out of hand a bit, and we tend to commit big batches of structural changes and justify them as refactoring. By contrast, tidyings are small, incremental improvements that don't require a deep understanding of the codebase. Structural and Behavioral Changes In the second part of the book, Kent Beck discusses the two main types of software changes : those related to structure and those related to behavior . He emphasizes categorizing changes into these groups and advocates for separate pull requests for structural and behavioral modifications . While many technical books offer rigid sets of rules to adhere to, Tidy First? presents a set of questions and ideas that will serve as a guide to aid you in making the best decisions for your particular use case. For instance, the book doesn't provide a definitive answer regarding the timing of structural changes: Should they precede the implementation of the required feature? - Possible . Should we tidy the code after implementing a new feature? - Maybe . Should we tidy the code at all? - it depends . Changers and Observers \"Software design is an exercise in human relationships\" Kent Beck The last section of the book delves into more theoretical concepts, like coupling and cohesion . Another interesting discussion in this section analyzes the two main attributes that make the software valuable: what it can do and what it can become . Needless to say, we'll use behavioral changes to define \"what software can do\", and structural changes to keep the options open for \"what it can become\". As a technical person, the importance of structural changes is obvious: they make future behavioral changes easy. However, these improvements may be less appealing to those unfamiliar with technical aspects. Kent Beck categorizes people into \"changers\" - developers who can modify the code, and \"observers\" - those who can only observe the system's behavior. He emphasizes that these two groups' ongoing collaboration and interaction leads to the eventual design of the system. My Commitments I like the way the book is written: it offers questions rather than rules. It made me think of my team and our projects. It made me question big batches of changes, regardless of their type. It made me commit that I will: Keep a short feedback loop : use more granular PRs, merge and release more often; Use different commits (at least) to separate behavioral and structural changes; Actively think about how each component can evolve; Always be aware of the impact of my changes: they should either immediately produce value (by increasing revenue or cutting costs), or keep the options open for the future.","title":"'Tidy First?' and my Post-Reading Commitments"},{"location":"blog/tidy-first-commitments/#tidy-first-and-my-post-reading-commitments","text":"Published: April 11, 2024 #software design #books You know that good feeling when you come across a piece of code that's concise and cohesive? The code that allows you to focus on its purpose, and it doesn't have logic scattered all over the place? That's the same feeling I've got reading Kent Beck's \"Tidy First?\" . It's a remarkably succinct book, spanning just 100 pages, divided into three sections, each comprised of a handful of brief chapters. Some chapters are no longer than a single page, yet they're incredibly rich in content. At times, I found myself revisiting certain chapters to fully absorb their insights.","title":"'Tidy First?' and my Post-Reading Commitments"},{"location":"blog/tidy-first-commitments/#small-improvements-with-big-impact","text":"The first section of the book explains what \"tidyings\" are, and provides some practical examples for 15 of these small improvements. In essence, we can think of \"tidyings\" as the younger relatives of \"refactorings\". Some tidyings can be as simple as extracting explanatory variables and helper functions. You'll probably be familiar with these techniques, and your IDE should already have shortcuts for pretty much all of them. However, reading through this section will give you a feeling of the size and granularity of these changes. This will help you better understand the second section about rhythm and pace. Long story short, the concept of \"refactoring\" got out of hand a bit, and we tend to commit big batches of structural changes and justify them as refactoring. By contrast, tidyings are small, incremental improvements that don't require a deep understanding of the codebase.","title":"Small Improvements with Big Impact"},{"location":"blog/tidy-first-commitments/#structural-and-behavioral-changes","text":"In the second part of the book, Kent Beck discusses the two main types of software changes : those related to structure and those related to behavior . He emphasizes categorizing changes into these groups and advocates for separate pull requests for structural and behavioral modifications . While many technical books offer rigid sets of rules to adhere to, Tidy First? presents a set of questions and ideas that will serve as a guide to aid you in making the best decisions for your particular use case. For instance, the book doesn't provide a definitive answer regarding the timing of structural changes: Should they precede the implementation of the required feature? - Possible . Should we tidy the code after implementing a new feature? - Maybe . Should we tidy the code at all? - it depends .","title":"Structural and Behavioral Changes"},{"location":"blog/tidy-first-commitments/#changers-and-observers","text":"\"Software design is an exercise in human relationships\" Kent Beck The last section of the book delves into more theoretical concepts, like coupling and cohesion . Another interesting discussion in this section analyzes the two main attributes that make the software valuable: what it can do and what it can become . Needless to say, we'll use behavioral changes to define \"what software can do\", and structural changes to keep the options open for \"what it can become\". As a technical person, the importance of structural changes is obvious: they make future behavioral changes easy. However, these improvements may be less appealing to those unfamiliar with technical aspects. Kent Beck categorizes people into \"changers\" - developers who can modify the code, and \"observers\" - those who can only observe the system's behavior. He emphasizes that these two groups' ongoing collaboration and interaction leads to the eventual design of the system.","title":"Changers and Observers"},{"location":"blog/tidy-first-commitments/#my-commitments","text":"I like the way the book is written: it offers questions rather than rules. It made me think of my team and our projects. It made me question big batches of changes, regardless of their type. It made me commit that I will: Keep a short feedback loop : use more granular PRs, merge and release more often; Use different commits (at least) to separate behavioral and structural changes; Actively think about how each component can evolve; Always be aware of the impact of my changes: they should either immediately produce value (by increasing revenue or cutting costs), or keep the options open for the future.","title":"My Commitments"}]}
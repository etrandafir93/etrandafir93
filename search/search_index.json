{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Emanuel Trandafir Hey there, I'm Emanuel - a Software Craftsman from Romania. I value simplicity and intentionality over blindly applying patterns and abstractions. I care deeply about the design and testability of the software I create. I also value communication and collaboration and enjoy sharing my knowledge through open-source contributions and technical articles. Browse articles by topic: #design (5) #functional programming (3) #testing (3) #debugging (2) #oss (2) #kafka (1) #oop (1) #books (1) The Case of the Vanishing Schema Field Uncle Bob's Advice on Stability and Abstractions Java's Optional vs Kotlin: Side by Side Lombok's \"Lazy\" Magic and the O.O.P. Alternative Less Mocks, More Functions! The Case of the Sometimes-Null Constant The Case of the Vanishing Schema Field The Case of the Vanishing Schema Field Clojure Threading for Dummy Java Devs (such as myself) Java's Optional vs Kotlin: Side by Side Less Mocks, More Functions! Lombok's \"Lazy\" Magic and the O.O.P. Alternative My First Contribution to Micrometer The Case of the Vanishing Schema Field Less Mocks, More Functions! The Case of the Sometimes-Null Constant My First Contribution to Micrometer 'Tidy First?' and my Post-Reading Commitments let currentActive = null; function showArticles(tag) { const articleDiv = document.getElementById(tag + '-articles'); const buttons = document.querySelectorAll('.tag-chip'); // If clicking the same tag, close it if (currentActive === articleDiv) { articleDiv.classList.remove('active'); buttons.forEach(btn => btn.classList.remove('active')); currentActive = null; return; } // Hide all article containers and remove active state from buttons document.querySelectorAll('.articles-container').forEach(div => { div.classList.remove('active'); }); buttons.forEach(btn => btn.classList.remove('active')); // Show selected articles and highlight button articleDiv.classList.add('active'); event.target.classList.add('active'); currentActive = articleDiv; } // Auto-expand tag based on URL hash on page load window.addEventListener('DOMContentLoaded', function() { const hash = window.location.hash.substring(1); // Remove the '#' if (hash) { const articleDiv = document.getElementById(hash + '-articles'); const button = Array.from(document.querySelectorAll('.tag-chip')) .find(btn => btn.getAttribute('onclick').includes(`'${hash}'`)); if (articleDiv && button) { articleDiv.classList.add('active'); button.classList.add('active'); currentActive = articleDiv; } } // Newsletter form handling const form = document.getElementById('newsletter-form'); const messageDiv = document.getElementById('newsletter-message'); form.addEventListener('submit', async function(e) { e.preventDefault(); const email = document.getElementById('bd-email').value; const submitBtn = form.querySelector('input[type=\"submit\"]'); const originalBtnText = submitBtn.value; submitBtn.value = 'Subscribing...'; submitBtn.disabled = true; try { const response = await fetch('https://buttondown.email/api/emails/embed-subscribe/etrandafir', { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded', }, body: `email=${encodeURIComponent(email)}` }); if (response.ok) { messageDiv.textContent = 'Successfully subscribed! Check your email to confirm.'; messageDiv.style.display = 'block'; messageDiv.style.background = 'rgba(80, 250, 123, 0.2)'; messageDiv.style.border = '2px solid #50fa7b'; messageDiv.style.color = '#50fa7b'; form.reset(); } else { throw new Error('Subscription failed'); } } catch (error) { messageDiv.textContent = 'Something went wrong. Please try again.'; messageDiv.style.display = 'block'; messageDiv.style.background = 'rgba(255, 85, 85, 0.2)'; messageDiv.style.border = '2px solid #ff5555'; messageDiv.style.color = '#ff5555'; } finally { submitBtn.value = originalBtnText; submitBtn.disabled = false; } }); });","title":"--- About Me ---"},{"location":"#emanuel-trandafir","text":"Hey there, I'm Emanuel - a Software Craftsman from Romania. I value simplicity and intentionality over blindly applying patterns and abstractions. I care deeply about the design and testability of the software I create. I also value communication and collaboration and enjoy sharing my knowledge through open-source contributions and technical articles. Browse articles by topic: #design (5) #functional programming (3) #testing (3) #debugging (2) #oss (2) #kafka (1) #oop (1) #books (1) The Case of the Vanishing Schema Field Uncle Bob's Advice on Stability and Abstractions Java's Optional vs Kotlin: Side by Side Lombok's \"Lazy\" Magic and the O.O.P. Alternative Less Mocks, More Functions! The Case of the Sometimes-Null Constant The Case of the Vanishing Schema Field The Case of the Vanishing Schema Field Clojure Threading for Dummy Java Devs (such as myself) Java's Optional vs Kotlin: Side by Side Less Mocks, More Functions! Lombok's \"Lazy\" Magic and the O.O.P. Alternative My First Contribution to Micrometer The Case of the Vanishing Schema Field Less Mocks, More Functions! The Case of the Sometimes-Null Constant My First Contribution to Micrometer 'Tidy First?' and my Post-Reading Commitments let currentActive = null; function showArticles(tag) { const articleDiv = document.getElementById(tag + '-articles'); const buttons = document.querySelectorAll('.tag-chip'); // If clicking the same tag, close it if (currentActive === articleDiv) { articleDiv.classList.remove('active'); buttons.forEach(btn => btn.classList.remove('active')); currentActive = null; return; } // Hide all article containers and remove active state from buttons document.querySelectorAll('.articles-container').forEach(div => { div.classList.remove('active'); }); buttons.forEach(btn => btn.classList.remove('active')); // Show selected articles and highlight button articleDiv.classList.add('active'); event.target.classList.add('active'); currentActive = articleDiv; } // Auto-expand tag based on URL hash on page load window.addEventListener('DOMContentLoaded', function() { const hash = window.location.hash.substring(1); // Remove the '#' if (hash) { const articleDiv = document.getElementById(hash + '-articles'); const button = Array.from(document.querySelectorAll('.tag-chip')) .find(btn => btn.getAttribute('onclick').includes(`'${hash}'`)); if (articleDiv && button) { articleDiv.classList.add('active'); button.classList.add('active'); currentActive = articleDiv; } } // Newsletter form handling const form = document.getElementById('newsletter-form'); const messageDiv = document.getElementById('newsletter-message'); form.addEventListener('submit', async function(e) { e.preventDefault(); const email = document.getElementById('bd-email').value; const submitBtn = form.querySelector('input[type=\"submit\"]'); const originalBtnText = submitBtn.value; submitBtn.value = 'Subscribing...'; submitBtn.disabled = true; try { const response = await fetch('https://buttondown.email/api/emails/embed-subscribe/etrandafir', { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded', }, body: `email=${encodeURIComponent(email)}` }); if (response.ok) { messageDiv.textContent = 'Successfully subscribed! Check your email to confirm.'; messageDiv.style.display = 'block'; messageDiv.style.background = 'rgba(80, 250, 123, 0.2)'; messageDiv.style.border = '2px solid #50fa7b'; messageDiv.style.color = '#50fa7b'; form.reset(); } else { throw new Error('Subscription failed'); } } catch (error) { messageDiv.textContent = 'Something went wrong. Please try again.'; messageDiv.style.display = 'block'; messageDiv.style.background = 'rgba(255, 85, 85, 0.2)'; messageDiv.style.border = '2px solid #ff5555'; messageDiv.style.color = '#ff5555'; } finally { submitBtn.value = originalBtnText; submitBtn.disabled = false; } }); });","title":"Emanuel Trandafir"},{"location":"blog/avro-duplicate-class-mystery/","text":"The Case of the Vanishing Schema Field Published: December 27, 2025 #debugging #design #kafka This is the story of a bug that appeared and disappeared at random. It's about decompiled JARs, schema ownership, code generation, and the JVM classloader. The Setup Our microservices relied on Apache Avro for serializing data through Kafka. At the center of it all was a simple schema: MoneyAmount.avsc . { \"namespace\": \"com.etrandafir.blog.samples\", \"type\": \"record\", \"name\": \"MoneyAmount\", \"fields\": [ {\"name\": \"amount\", \"type\": \"double\"}, {\"name\": \"currency\", \"type\": \"string\"} ] } When we looked into how to make the change, we discovered that Order.avsc and MoneyAmount.avsc lived in different repositories. The order-api library was pulling in MoneyAmount.avsc from its remote location to generate the Java classes during build time. At some point, somebody had tried to build MoneyAmount as a separate JAR in a commons library. But that didn't work\u2014libraries like order-api needed the MoneyAmount.avsc file itself during their build process to generate Java classes from schemas that referenced it. So that initiative got abandoned pretty quick, and we kept the setup as-is. The Change One day, a requirement came in: \"We need the currency symbol (like $, \u20ac, \u00a3) in our Order events.\" Simple enough. We added a new field to MoneyAmount.avsc : { \"namespace\": \"com.etrandafir.blog.samples\", \"type\": \"record\", \"name\": \"MoneyAmount\", \"fields\": [ {\"name\": \"amount\", \"type\": \"double\"}, {\"name\": \"currency\", \"type\": \"string\"}, {\"name\": \"symbol\", \"type\": \"string\", \"default\": \"\"} ] } We updated order-api , rebuilt it, ran the tests locally\u2014everything passed. We pushed to the test environment. Still green. We were ready for production. Later That Week Then, a different team integrated a completely unrelated feature. They re-deployed the application to the test environment. Boom. org.apache.avro.AvroRuntimeException: Unknown field: symbol The application crashed during serialization. MoneyAmount objects suddenly didn't have a symbol field anymore. \"It must be the new feature,\" someone said. We quickly checked \u2014no, the new feature had nothing to do with orders. We rolled it back anyway. Restarted the service. Everything worked again. Wait, what? Phantom Restarts and Forgotten Libs We had a mystery on our hands. The behavior was completely non-deterministic: Tests were passing locally Tests were passing in CI/CD Sometimes the service worked fine after restart Sometimes it failed after restart We pulled the order-api JAR from Artifactory and decompiled it. There it was\u2014the MoneyAmount class with the symbol field, exactly as expected. \"The JAR is correct\" - we thought. \"So what's going on?\" Then someone asked: \"Are there any other libraries use the _MoneyAmount schema?\" We checked. The _payment-api library also had Avro schema generation configured. It pulled MoneyAmount.avsc and generated its own MoneyAmount java class. \"When was payment-api last built?\" We checked the timestamps. One month ago. Before our schema change. The pieces started falling into place. The Smoking Gun Both order-api and payment-api were generating their own MoneyAmount classes from the same Avro schema . Since both versions of the schema had the same namespace , both generated classes had the same fully qualified name. At runtime, the JVM encountered two different versions of the same class on the classpath . Here's the issue, reproduced in a simplified setup. Which version gets loaded? Will this main() method work or fail? Turns out the JVM will silently pick one and discard the other - not even a warning . It all depends on the classpath order. For instance, we can force loading the order-api.jar first by running the application this way: java -cp ^ \"order-api/target/order-api-1.0-SNAPSHOT.jar;^ payment-api/target/payment-api-1.0-SNAPSHOT.jar;^ dummy-app/target/dummy-app-1.0-SNAPSHOT.jar\" ^ com.etrandafir.blog.app.DummyApp This will result in the happy path we were usually seeing, in our example, the toString() of the MoneyAmount object: MoneyAmount[amount=100.50, currency=USD, currencySymbol=$] On the other hand, we can reverse the order of the JARs, the main() method will fail to create a MoneyAmount instance. It'll say it's not aware of a MoneyAmount constructor accepting three parameters (amount, currency, symbol), it only knows the old two-parameter constructor: Exception in thread \"main\" java.lang.NoSuchMethodError: 'void com.etrandafir.blog.samples.MoneyAmount.<init>(java.math.BigDecimal, java.lang.String, java.lang.String)' at com.etrandafir.blog.app.DummyApp.main(DummyApp.java:10) The JAR ordering was effectively random during service startup, which explained the non-deterministic behavior. What Went Wrong We had violated a fundamental principle: a generated class should have exactly one owner. Our setup allowed multiple libraries to independently generate the same class from the same schema. When the schema evolved, each library built its own version at different times, creating conflicting definitions on the classpath. The JVM's classloader picked one version at random, making the behavior completely non-deterministic. But there's a deeper issue here. In Domain-Driven Design terms, payment-api and order-api represent different bounded contexts. Each context should own its data models. If both contexts needed a money concept, each should have declared its own MoneyAmount schema \u2014even if they looked similar. Instead, we had a shared schema with no clear ownership, living in a separate repository that neither context truly controlled. How We Could Have Caught It Earlier The service in our test environment was rarely restarted, but our CI/CD pipeline ran tests constantly. If we had integration tests that actually went through the Kafka layer , we would have caught this much earlier. Using tools like Testcontainers or Embedded Kafka would have surfaced the issue. Sure, this test might have produced some false negatives, but it would have been failing often enough for us to investigate. Another tool that could have saved us is the Maven Enforcer Plugin with its banDuplicateClasses rule. This plugin scans your dependencies at build time and fails the build if it detects multiple JARs providing the same class. If we had configured it in our projects, the build would have failed immediately, preventing the duplicate MoneyAmount classes from ever reaching our test environment. Let's add the Maven Enforcer Plugin to our sample project's pom.xml : <build> <plugins> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-enforcer-plugin</artifactId> <version>3.6.2</version> <executions> <execution> <id>enforce-ban-duplicate-classes</id> <goals> <goal>enforce</goal> </goals> <configuration> <rules> <banDuplicateClasses> <findAllDuplicates>true</findAllDuplicates> <ignoreWhenIdentical>true</ignoreWhenIdentical> </banDuplicateClasses> </rules> <fail>true</fail> </configuration> </execution> </executions> <dependencies> <dependency> <groupId>org.codehaus.mojo</groupId> <artifactId>extra-enforcer-rules</artifactId> <version>1.11.0</version> </dependency> </dependencies> </plugin> </plugins> </build> After configuring this plugin, any attempt to build a project with duplicate classes would fail immediately. Let's try it out in our sample project: [INFO] ------------------------------------------------------------------------ [INFO] Reactor Summary for duplicate-classes 1.0-SNAPSHOT: [INFO] [INFO] duplicate-classes .................................. SUCCESS [ 0.186 s] [INFO] payment-api ........................................ SUCCESS [ 0.853 s] [INFO] order-api .......................................... SUCCESS [ 0.083 s] [INFO] dummy-app .......................................... FAILURE [ 2.575 s] [INFO] ------------------------------------------------------------------------ [INFO] BUILD FAILURE [INFO] ------------------------------------------------------------------------ [INFO] Total time: 3.778 s [INFO] Finished at: 2025-12-28T17:19:12+02:00 [INFO] ------------------------------------------------------------------------ [ERROR] Failed to execute goal org.apache.maven.plugins:maven-enforcer-plugin:3.6.2:enforce (enforce-ban-duplicate-classes) on project dummy-app: [ERROR] Rule 0: org.codehaus.mojo.extraenforcer.dependencies.BanDuplicateClasses failed with message: [ERROR] Duplicate classes found: [ERROR] [ERROR] Found in: [ERROR] com.etrandafir.blog:payment-api:jar:1.0-SNAPSHOT:compile [ERROR] com.etrandafir.blog:order-api:jar:1.0-SNAPSHOT:compile [ERROR] Duplicate classes: [ERROR] com/etrandafir/blog/samples/MoneyAmount.class Lessons Learned Generated code should have exactly one owner Avoid committing generated files\u2014generate during build Allow each bounded context to define its own models, even if they look similar Unit tests aren't enough This bug taught us that architectural mistakes don't always fail immediately. They lie dormant, waiting for the perfect storm: a schema change, a deployment, a classloader race condition. You can play with a demo project and try the Maven plugin yourself at github.com/etrandafir93/dupped_java_classes .","title":"The Case of the Vanishing Schema Field"},{"location":"blog/avro-duplicate-class-mystery/#the-case-of-the-vanishing-schema-field","text":"Published: December 27, 2025 #debugging #design #kafka This is the story of a bug that appeared and disappeared at random. It's about decompiled JARs, schema ownership, code generation, and the JVM classloader.","title":"The Case of the Vanishing Schema Field"},{"location":"blog/avro-duplicate-class-mystery/#the-setup","text":"Our microservices relied on Apache Avro for serializing data through Kafka. At the center of it all was a simple schema: MoneyAmount.avsc . { \"namespace\": \"com.etrandafir.blog.samples\", \"type\": \"record\", \"name\": \"MoneyAmount\", \"fields\": [ {\"name\": \"amount\", \"type\": \"double\"}, {\"name\": \"currency\", \"type\": \"string\"} ] } When we looked into how to make the change, we discovered that Order.avsc and MoneyAmount.avsc lived in different repositories. The order-api library was pulling in MoneyAmount.avsc from its remote location to generate the Java classes during build time. At some point, somebody had tried to build MoneyAmount as a separate JAR in a commons library. But that didn't work\u2014libraries like order-api needed the MoneyAmount.avsc file itself during their build process to generate Java classes from schemas that referenced it. So that initiative got abandoned pretty quick, and we kept the setup as-is.","title":"The Setup"},{"location":"blog/avro-duplicate-class-mystery/#the-change","text":"One day, a requirement came in: \"We need the currency symbol (like $, \u20ac, \u00a3) in our Order events.\" Simple enough. We added a new field to MoneyAmount.avsc : { \"namespace\": \"com.etrandafir.blog.samples\", \"type\": \"record\", \"name\": \"MoneyAmount\", \"fields\": [ {\"name\": \"amount\", \"type\": \"double\"}, {\"name\": \"currency\", \"type\": \"string\"}, {\"name\": \"symbol\", \"type\": \"string\", \"default\": \"\"} ] } We updated order-api , rebuilt it, ran the tests locally\u2014everything passed. We pushed to the test environment. Still green. We were ready for production.","title":"The Change"},{"location":"blog/avro-duplicate-class-mystery/#later-that-week","text":"Then, a different team integrated a completely unrelated feature. They re-deployed the application to the test environment. Boom. org.apache.avro.AvroRuntimeException: Unknown field: symbol The application crashed during serialization. MoneyAmount objects suddenly didn't have a symbol field anymore. \"It must be the new feature,\" someone said. We quickly checked \u2014no, the new feature had nothing to do with orders. We rolled it back anyway. Restarted the service. Everything worked again. Wait, what?","title":"Later That Week"},{"location":"blog/avro-duplicate-class-mystery/#phantom-restarts-and-forgotten-libs","text":"We had a mystery on our hands. The behavior was completely non-deterministic: Tests were passing locally Tests were passing in CI/CD Sometimes the service worked fine after restart Sometimes it failed after restart We pulled the order-api JAR from Artifactory and decompiled it. There it was\u2014the MoneyAmount class with the symbol field, exactly as expected. \"The JAR is correct\" - we thought. \"So what's going on?\" Then someone asked: \"Are there any other libraries use the _MoneyAmount schema?\" We checked. The _payment-api library also had Avro schema generation configured. It pulled MoneyAmount.avsc and generated its own MoneyAmount java class. \"When was payment-api last built?\" We checked the timestamps. One month ago. Before our schema change. The pieces started falling into place.","title":"Phantom Restarts and Forgotten Libs"},{"location":"blog/avro-duplicate-class-mystery/#the-smoking-gun","text":"Both order-api and payment-api were generating their own MoneyAmount classes from the same Avro schema . Since both versions of the schema had the same namespace , both generated classes had the same fully qualified name. At runtime, the JVM encountered two different versions of the same class on the classpath . Here's the issue, reproduced in a simplified setup. Which version gets loaded? Will this main() method work or fail? Turns out the JVM will silently pick one and discard the other - not even a warning . It all depends on the classpath order. For instance, we can force loading the order-api.jar first by running the application this way: java -cp ^ \"order-api/target/order-api-1.0-SNAPSHOT.jar;^ payment-api/target/payment-api-1.0-SNAPSHOT.jar;^ dummy-app/target/dummy-app-1.0-SNAPSHOT.jar\" ^ com.etrandafir.blog.app.DummyApp This will result in the happy path we were usually seeing, in our example, the toString() of the MoneyAmount object: MoneyAmount[amount=100.50, currency=USD, currencySymbol=$] On the other hand, we can reverse the order of the JARs, the main() method will fail to create a MoneyAmount instance. It'll say it's not aware of a MoneyAmount constructor accepting three parameters (amount, currency, symbol), it only knows the old two-parameter constructor: Exception in thread \"main\" java.lang.NoSuchMethodError: 'void com.etrandafir.blog.samples.MoneyAmount.<init>(java.math.BigDecimal, java.lang.String, java.lang.String)' at com.etrandafir.blog.app.DummyApp.main(DummyApp.java:10) The JAR ordering was effectively random during service startup, which explained the non-deterministic behavior.","title":"The Smoking Gun"},{"location":"blog/avro-duplicate-class-mystery/#what-went-wrong","text":"We had violated a fundamental principle: a generated class should have exactly one owner. Our setup allowed multiple libraries to independently generate the same class from the same schema. When the schema evolved, each library built its own version at different times, creating conflicting definitions on the classpath. The JVM's classloader picked one version at random, making the behavior completely non-deterministic. But there's a deeper issue here. In Domain-Driven Design terms, payment-api and order-api represent different bounded contexts. Each context should own its data models. If both contexts needed a money concept, each should have declared its own MoneyAmount schema \u2014even if they looked similar. Instead, we had a shared schema with no clear ownership, living in a separate repository that neither context truly controlled.","title":"What Went Wrong"},{"location":"blog/avro-duplicate-class-mystery/#how-we-could-have-caught-it-earlier","text":"The service in our test environment was rarely restarted, but our CI/CD pipeline ran tests constantly. If we had integration tests that actually went through the Kafka layer , we would have caught this much earlier. Using tools like Testcontainers or Embedded Kafka would have surfaced the issue. Sure, this test might have produced some false negatives, but it would have been failing often enough for us to investigate. Another tool that could have saved us is the Maven Enforcer Plugin with its banDuplicateClasses rule. This plugin scans your dependencies at build time and fails the build if it detects multiple JARs providing the same class. If we had configured it in our projects, the build would have failed immediately, preventing the duplicate MoneyAmount classes from ever reaching our test environment. Let's add the Maven Enforcer Plugin to our sample project's pom.xml : <build> <plugins> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-enforcer-plugin</artifactId> <version>3.6.2</version> <executions> <execution> <id>enforce-ban-duplicate-classes</id> <goals> <goal>enforce</goal> </goals> <configuration> <rules> <banDuplicateClasses> <findAllDuplicates>true</findAllDuplicates> <ignoreWhenIdentical>true</ignoreWhenIdentical> </banDuplicateClasses> </rules> <fail>true</fail> </configuration> </execution> </executions> <dependencies> <dependency> <groupId>org.codehaus.mojo</groupId> <artifactId>extra-enforcer-rules</artifactId> <version>1.11.0</version> </dependency> </dependencies> </plugin> </plugins> </build> After configuring this plugin, any attempt to build a project with duplicate classes would fail immediately. Let's try it out in our sample project: [INFO] ------------------------------------------------------------------------ [INFO] Reactor Summary for duplicate-classes 1.0-SNAPSHOT: [INFO] [INFO] duplicate-classes .................................. SUCCESS [ 0.186 s] [INFO] payment-api ........................................ SUCCESS [ 0.853 s] [INFO] order-api .......................................... SUCCESS [ 0.083 s] [INFO] dummy-app .......................................... FAILURE [ 2.575 s] [INFO] ------------------------------------------------------------------------ [INFO] BUILD FAILURE [INFO] ------------------------------------------------------------------------ [INFO] Total time: 3.778 s [INFO] Finished at: 2025-12-28T17:19:12+02:00 [INFO] ------------------------------------------------------------------------ [ERROR] Failed to execute goal org.apache.maven.plugins:maven-enforcer-plugin:3.6.2:enforce (enforce-ban-duplicate-classes) on project dummy-app: [ERROR] Rule 0: org.codehaus.mojo.extraenforcer.dependencies.BanDuplicateClasses failed with message: [ERROR] Duplicate classes found: [ERROR] [ERROR] Found in: [ERROR] com.etrandafir.blog:payment-api:jar:1.0-SNAPSHOT:compile [ERROR] com.etrandafir.blog:order-api:jar:1.0-SNAPSHOT:compile [ERROR] Duplicate classes: [ERROR] com/etrandafir/blog/samples/MoneyAmount.class","title":"How We Could Have Caught It Earlier"},{"location":"blog/avro-duplicate-class-mystery/#lessons-learned","text":"Generated code should have exactly one owner Avoid committing generated files\u2014generate during build Allow each bounded context to define its own models, even if they look similar Unit tests aren't enough This bug taught us that architectural mistakes don't always fail immediately. They lie dormant, waiting for the perfect storm: a schema change, a deployment, a classloader race condition. You can play with a demo project and try the Maven plugin yourself at github.com/etrandafir93/dupped_java_classes .","title":"Lessons Learned"},{"location":"blog/circular-initialization-mystery/","text":"The Case of the Sometimes-Null Constant Published: January 31, 2026 #oss #debugging This is the story of a flaky test that was passing for all the wrong reasons. It's about null comparisons, circular dependencies, class initialization order, and how the JVM can surprise you when you least expect it. The Crime Scene I came across an issue in the Micrometer metrics library about flaky tests in NoopObservationRegistryTests . The tests were randomly failing with a cryptic assertion error: java.lang.AssertionError: Expecting actual: null and: io.micrometer.observation.NoopObservation$NoopScope@2f08c4b to refer to the same object The tests were using AssertJ's isSameAs() to verify that certain fields were pointing to the same singleton instance. Most times they passed. But every once in a while they failed. Classic flaky test behavior. \"It must be a concurrency issue,\" I thought. \"Or maybe some shared state between tests?\" But as I dug deeper, I realized something far more interesting was happening. Finding a Lead Here's a simplified version of what the test was doing: @Test void shouldNotRespectScopesIfNoopRegistryIsUsed() { ObservationRegistry registry = ObservationRegistry.NOOP; Observation observation = Observation.start(\"foo\", registry); try (Observation.Scope scope = observation.openScope()) { then(registry.getCurrentObservationScope()) .isSameAs(Observation.Scope.NOOP); } } The assertion was checking that the current scope was the same instance as Observation.Scope.NOOP \u2014a public static final singleton. I set a breakpoint right before the assertion in one of the passing test runs. Both the actual and expected values were null \u2014that's why the tests were passing most of the time! The test was effectively doing: then(null).isSameAs(null); When both were null , the test passed. But sometimes, very rarely, the Observation.Scope.NOOP wasn't null \u2014and the test failed. So, getCurrentObservationScope() was always returning null . The flaky test wasn't revealing a bug in the test logic. It was revealing a bug in the production code. That's good to know, it can be dealt with in a different issue. But, for me, the more interesting question was: How could Scope.NOOP be null as well? It's a singleton static final field - is this even possible? Following the Trail Let's take a closer look at the simplified code snippet: interface Scope { Scope NOOP = NoopScope.INSTANCE; // ... } class NoopScope implements Scope { static final Scope INSTANCE = new NoopScope(); // ... } Do you notice anything peculiar? Take a moment to think about it. (see the answer) There's a circular dependency during class initialization: Scope.NOOP points to NoopScope.INSTANCE NoopScope implements Scope When the JVM initializes NoopScope.INSTANCE first: It loads the NoopScope class Since NoopScope implements Scope , it loads the Scope interface The interface tries to initialize Scope.NOOP by referencing NoopScope.INSTANCE But NoopScope.INSTANCE isn't fully initialized yet\u2014it's still being created! Scope.NOOP ends up as null The initialization order depended on which class the JVM happened to load first. Hence, the flaky behavior. The Smoking Gun I was very surprised by this behavior, and I needed to be absolutely sure. Turns out even a plain-old System.out.println() would be enough to change the class initialization order, and reproduce the issue reliably: @Test void test() { // this sysout will force initializing NoopScope.INSTANCE first System.out.println(NoopScope.INSTANCE); then(Scope.NOOP).isNotNull(); // FAILS } Of course, we'll run this test in isolation to avoid having other tests interfere with the order of loading the classes. Bingo! By forcing the classloader to initialize NoopScope first, we could reliably make Scope.NOOP become null every single time. Comment out that first println() and run again \u2014the behavior changes completely! The test passes. The Solution I tried several approaches to fix this, but they all broke backward compatibility. Needless to say, that was not an option for a widely-used library such as Micrometer. The public API couldn't change\u2014 Scope.NOOP needed to remain a public static final field. That's when the Micrometer team came up with an ingenious solution: replace the concrete class references with anonymous inner classes . Of course, the full implementation is more complex, feel free to check out all the changes here. But, for now, let's stick to our simplified code sample. Instead of: interface Scope { Scope NOOP = NoopScope.INSTANCE; // Circular reference! } They used: interface Scope { // Anonymous class - no circular reference possible Scope NOOP = new Scope() { @Override public Observation getCurrentObservation() { // ... implementation ... } // ... other methods... }; } The anonymous inner class is part of the Scope interface's initialization, so there's no external dependency that could cause a circular initialization. Simply put, the Scope interface still has a public static Scope field, but we removed the references to any concrete implementation. How to Catch This Early Apart from fixing the bug, we need to make sure this kind of issue wouldn't happen again in the future. Turns out there's an ErrorProne check specifically for this: ClassInitializationDeadlock . This static analysis rule can detect circular initialization dependencies at compile time. Adding it to the build configuration: errorprone { check(\"ClassInitializationDeadlock\", CheckSeverity.ERROR) } Now the build would fail immediately if anyone introduced this pattern again. In a different PR , this was integrated, too, into Micrometer's build process. Lessons Learned Flaky tests are sometimes symptoms of real bugs Circular dependencies between static fields can create subtle, non-deterministic bugs ErrorProne and other static analysis tools can catch these issues before they reach production You can see the full investigation and discussion in the original issue .","title":"The Case of the Sometimes-Null Constant"},{"location":"blog/circular-initialization-mystery/#the-case-of-the-sometimes-null-constant","text":"Published: January 31, 2026 #oss #debugging This is the story of a flaky test that was passing for all the wrong reasons. It's about null comparisons, circular dependencies, class initialization order, and how the JVM can surprise you when you least expect it.","title":"The Case of the Sometimes-Null Constant"},{"location":"blog/circular-initialization-mystery/#the-crime-scene","text":"I came across an issue in the Micrometer metrics library about flaky tests in NoopObservationRegistryTests . The tests were randomly failing with a cryptic assertion error: java.lang.AssertionError: Expecting actual: null and: io.micrometer.observation.NoopObservation$NoopScope@2f08c4b to refer to the same object The tests were using AssertJ's isSameAs() to verify that certain fields were pointing to the same singleton instance. Most times they passed. But every once in a while they failed. Classic flaky test behavior. \"It must be a concurrency issue,\" I thought. \"Or maybe some shared state between tests?\" But as I dug deeper, I realized something far more interesting was happening.","title":"The Crime Scene"},{"location":"blog/circular-initialization-mystery/#finding-a-lead","text":"Here's a simplified version of what the test was doing: @Test void shouldNotRespectScopesIfNoopRegistryIsUsed() { ObservationRegistry registry = ObservationRegistry.NOOP; Observation observation = Observation.start(\"foo\", registry); try (Observation.Scope scope = observation.openScope()) { then(registry.getCurrentObservationScope()) .isSameAs(Observation.Scope.NOOP); } } The assertion was checking that the current scope was the same instance as Observation.Scope.NOOP \u2014a public static final singleton. I set a breakpoint right before the assertion in one of the passing test runs. Both the actual and expected values were null \u2014that's why the tests were passing most of the time! The test was effectively doing: then(null).isSameAs(null); When both were null , the test passed. But sometimes, very rarely, the Observation.Scope.NOOP wasn't null \u2014and the test failed. So, getCurrentObservationScope() was always returning null . The flaky test wasn't revealing a bug in the test logic. It was revealing a bug in the production code. That's good to know, it can be dealt with in a different issue. But, for me, the more interesting question was: How could Scope.NOOP be null as well? It's a singleton static final field - is this even possible?","title":"Finding a Lead"},{"location":"blog/circular-initialization-mystery/#following-the-trail","text":"Let's take a closer look at the simplified code snippet: interface Scope { Scope NOOP = NoopScope.INSTANCE; // ... } class NoopScope implements Scope { static final Scope INSTANCE = new NoopScope(); // ... } Do you notice anything peculiar? Take a moment to think about it. (see the answer) There's a circular dependency during class initialization: Scope.NOOP points to NoopScope.INSTANCE NoopScope implements Scope When the JVM initializes NoopScope.INSTANCE first: It loads the NoopScope class Since NoopScope implements Scope , it loads the Scope interface The interface tries to initialize Scope.NOOP by referencing NoopScope.INSTANCE But NoopScope.INSTANCE isn't fully initialized yet\u2014it's still being created! Scope.NOOP ends up as null The initialization order depended on which class the JVM happened to load first. Hence, the flaky behavior.","title":"Following the Trail"},{"location":"blog/circular-initialization-mystery/#the-smoking-gun","text":"I was very surprised by this behavior, and I needed to be absolutely sure. Turns out even a plain-old System.out.println() would be enough to change the class initialization order, and reproduce the issue reliably: @Test void test() { // this sysout will force initializing NoopScope.INSTANCE first System.out.println(NoopScope.INSTANCE); then(Scope.NOOP).isNotNull(); // FAILS } Of course, we'll run this test in isolation to avoid having other tests interfere with the order of loading the classes. Bingo! By forcing the classloader to initialize NoopScope first, we could reliably make Scope.NOOP become null every single time. Comment out that first println() and run again \u2014the behavior changes completely! The test passes.","title":"The Smoking Gun"},{"location":"blog/circular-initialization-mystery/#the-solution","text":"I tried several approaches to fix this, but they all broke backward compatibility. Needless to say, that was not an option for a widely-used library such as Micrometer. The public API couldn't change\u2014 Scope.NOOP needed to remain a public static final field. That's when the Micrometer team came up with an ingenious solution: replace the concrete class references with anonymous inner classes . Of course, the full implementation is more complex, feel free to check out all the changes here. But, for now, let's stick to our simplified code sample. Instead of: interface Scope { Scope NOOP = NoopScope.INSTANCE; // Circular reference! } They used: interface Scope { // Anonymous class - no circular reference possible Scope NOOP = new Scope() { @Override public Observation getCurrentObservation() { // ... implementation ... } // ... other methods... }; } The anonymous inner class is part of the Scope interface's initialization, so there's no external dependency that could cause a circular initialization. Simply put, the Scope interface still has a public static Scope field, but we removed the references to any concrete implementation.","title":"The Solution"},{"location":"blog/circular-initialization-mystery/#how-to-catch-this-early","text":"Apart from fixing the bug, we need to make sure this kind of issue wouldn't happen again in the future. Turns out there's an ErrorProne check specifically for this: ClassInitializationDeadlock . This static analysis rule can detect circular initialization dependencies at compile time. Adding it to the build configuration: errorprone { check(\"ClassInitializationDeadlock\", CheckSeverity.ERROR) } Now the build would fail immediately if anyone introduced this pattern again. In a different PR , this was integrated, too, into Micrometer's build process.","title":"How to Catch This Early"},{"location":"blog/circular-initialization-mystery/#lessons-learned","text":"Flaky tests are sometimes symptoms of real bugs Circular dependencies between static fields can create subtle, non-deterministic bugs ErrorProne and other static analysis tools can catch these issues before they reach production You can see the full investigation and discussion in the original issue .","title":"Lessons Learned"},{"location":"blog/clean-code-dependency-principles/","text":"Uncle Bob's Advice on Stability and Abstractions Published: December 13, 2025 #design Have you ever worked on a codebase where changing one module triggers a cascade of changes across the entire system? Or where circular dependencies make it nearly impossible to understand which component is responsible for what? Uncle Bob's Clean Code series addresses these issues with some fundamental principles for managing dependencies in software systems. In this short article, we'll discuss the incoming and outgoing dependencies of our software, and classify our components as stable or unstable . Then, we'll learn that stable component should be more abstract , whereas unstable components can remain concrete . Stable vs Unstable Components Let's imagine you built a small library for parsing CSV files. At first, only your team uses it - it's relatively unstable . You can make breaking changes without too much hassle. But then, you open-source it and it suddenly becomes super popular. Now thousands of projects depend on it, which makes it very stable . It's stable because you cannot afford to easily make breaking changes to it anymore. So, we can say that a component is stable if it has many components depending on it, while depending on few others itself. On the other hand, an unstable component has many efferent dependencies. According to Uncle Bob's Stable Dependencies Principle, a component should only depend on components that are more stable than itself. For instance, for your CSV parser library with thousands of users, it's ok to depend on a well-established date/time library which is even more popular. On the other hand, it would be a bad idea to add a dependency on a small utility library that is still evolving rapidly. Abstract vs Concrete Components Similar to stability, abstraction is not \"boolean\" either: A component does not have to be either abstract or concrete . The more abstract classes and interfaces a component has (compared to the total number of public classes), the more abstract it is. The Stable Abstractions Principle tells us that the more stable a component is, the more abstract it should be. Simply put, our popular CSV parser with a lot of users should be designed with abstraction in mind. This will allow us to further extend it without introducing breaking changes. Our CSV parser is stable and abstract! Let's imagine we also have a UI application that fetches data from multiple backend services and displays it to the user. Most probably, this application is going to have many outgoing dependencies. Moreover, it will enable the users to perform some operations that are very specific to our system. Therefore, we can say that our UI application is unstable and concrete. If we have a component that is unstable (few others depend on it & it has many other dependencies), there is no point in keeping it abstract - it'll be useless. On the other hand, a component that's stable (other modules depend on it) needs to be abstract - otherwise maintaining without breaking users will be painful. Consequently, we have to keep the proportions between stability and abstraction, aiming for the blue area of the graph. Takeaways These principles might sound theoretical, but they've changed how I approach component design. It's easy to go on autopilot (or copilot) when building new features - creating abstractions \"just in case\" or avoiding them entirely. Understanding stability and abstraction helps us make intentional decisions instead. Next time you're designing a component, ask yourself: How stable is this? How stable should it be? The answers will guide you toward the right level of abstraction - not too much, not too little.","title":"Uncle Bob's Advice on Stability and Abstractions"},{"location":"blog/clean-code-dependency-principles/#uncle-bobs-advice-on-stability-and-abstractions","text":"Published: December 13, 2025 #design Have you ever worked on a codebase where changing one module triggers a cascade of changes across the entire system? Or where circular dependencies make it nearly impossible to understand which component is responsible for what? Uncle Bob's Clean Code series addresses these issues with some fundamental principles for managing dependencies in software systems. In this short article, we'll discuss the incoming and outgoing dependencies of our software, and classify our components as stable or unstable . Then, we'll learn that stable component should be more abstract , whereas unstable components can remain concrete .","title":"Uncle Bob's Advice on Stability and Abstractions"},{"location":"blog/clean-code-dependency-principles/#stable-vs-unstable-components","text":"Let's imagine you built a small library for parsing CSV files. At first, only your team uses it - it's relatively unstable . You can make breaking changes without too much hassle. But then, you open-source it and it suddenly becomes super popular. Now thousands of projects depend on it, which makes it very stable . It's stable because you cannot afford to easily make breaking changes to it anymore. So, we can say that a component is stable if it has many components depending on it, while depending on few others itself. On the other hand, an unstable component has many efferent dependencies. According to Uncle Bob's Stable Dependencies Principle, a component should only depend on components that are more stable than itself. For instance, for your CSV parser library with thousands of users, it's ok to depend on a well-established date/time library which is even more popular. On the other hand, it would be a bad idea to add a dependency on a small utility library that is still evolving rapidly.","title":"Stable vs Unstable Components"},{"location":"blog/clean-code-dependency-principles/#abstract-vs-concrete-components","text":"Similar to stability, abstraction is not \"boolean\" either: A component does not have to be either abstract or concrete . The more abstract classes and interfaces a component has (compared to the total number of public classes), the more abstract it is. The Stable Abstractions Principle tells us that the more stable a component is, the more abstract it should be. Simply put, our popular CSV parser with a lot of users should be designed with abstraction in mind. This will allow us to further extend it without introducing breaking changes. Our CSV parser is stable and abstract! Let's imagine we also have a UI application that fetches data from multiple backend services and displays it to the user. Most probably, this application is going to have many outgoing dependencies. Moreover, it will enable the users to perform some operations that are very specific to our system. Therefore, we can say that our UI application is unstable and concrete. If we have a component that is unstable (few others depend on it & it has many other dependencies), there is no point in keeping it abstract - it'll be useless. On the other hand, a component that's stable (other modules depend on it) needs to be abstract - otherwise maintaining without breaking users will be painful. Consequently, we have to keep the proportions between stability and abstraction, aiming for the blue area of the graph.","title":"Abstract vs Concrete Components"},{"location":"blog/clean-code-dependency-principles/#takeaways","text":"These principles might sound theoretical, but they've changed how I approach component design. It's easy to go on autopilot (or copilot) when building new features - creating abstractions \"just in case\" or avoiding them entirely. Understanding stability and abstraction helps us make intentional decisions instead. Next time you're designing a component, ask yourself: How stable is this? How stable should it be? The answers will guide you toward the right level of abstraction - not too much, not too little.","title":"Takeaways"},{"location":"blog/clojure-threading/","text":"Clojure Threading for Dummy Java Devs (such as myself) Published: August 30, 2025 #clojure #java #functional programming Recently, I've been playing around with Clojure. I wanted to take advantage of the AI tools available to explore a new language... and not just Kotlin or Python, but something completely new to me. One of the features that caught my attention was the threading macros ( -> and ->> ) it's a pretty simple feature, but I found it interesting and elegant. Strava Heatmaps A few words about the project I've built in Clojure? Well, I'm recording all my sport activities using my Garmin watch, even when I'm playing football. When I get home and download my activity, the map looks something like the spaghetti code I generate when vibe-coding with ChatGPT: Needless to say, I want to visualize my football session a bit better. so I decided to build a small app to export this activity as a GPX file and generate an HTML heatmap based on it. After applying all these steps, we'll expect a heatmap like this: Basically, we need to: parse the GPX file (GPX is an XML schema designed as a common GPS data) normalize the data (optionally) rotate the activity by a given angle (optionally) filter the data - for eg.: by running cadence generate the heatmap generate the HTML file A functional language sounded like a perfect fit for implementing this pipeline of operations, so I decided to give Clojure a try. Before diving into the threading macros that make these pipelines so elegant, let's cover some Clojure basics. If you're coming from Java like me, the syntax might look intimidating at first, but the core concepts are actually quite straightforward once you get the hang of the parentheses. Clojure Syntax Let me show you what I understood about Clojure so far. The syntax follows a consistent pattern: (function-name arguments...) where the function always comes first inside the parentheses, followed by its arguments. For example, if we want to add two numbers (say 1 and 2) , we would write: ( + 1 2 ) . This is because + is the addition function, followed by 1 and 2 - the numbers being added. We can define a function using the defn keyword, followed by the function name, its arguments, and the body of the function. Let's write a function that adds two numbers, received as arguments: (defn add [a b] (+ a b)) Similarly, when we want to compare numbers, we'll start with the comparison function, followed by the numbers to compare. For instance, this is how we verify if two numbers (a and b) are equal: ( = a b ) Now let's write a unit test for our add function: (deftest add-two-test (is (= 3 (add 1 2) ) ) ) ;; or simply: (deftest add-two-test (is (= 3 (add 1 2)))) The Threading Macros Look at our test: as simple as it is, it already has quite a few nested function calls. If we read it from right to left, we can see that we're: adding 1 and 2 comparing the result with 3 verifying if the result is true When it comes to pipelines of operations, the threading macros ( -> and ->> ) allows us to take the result of one operation and pass it as argument to the next operation. The difference between the two is that -> ( aka thread-first ) passes the value to the next function as the first argument, while ->> ( aka thread-last ) passes the value as the last argument. Therefore, we can re-write our test as follows: (deftest add-two-test-x (->> 1 (add 2) (= 3) (is))) And it reads like this: we start with the number 1, then we add 2 to it, then we compare the result with 3, and finally we verify if the new result is true. Of course, this is a very simple example, but it shows the power of the threading macros. Let's go back to our heatmap pipeline: As discussed, we'll start with a GPX file that we need to read as text. Then, we'll parse its content and normalize the data. At this point, we can optionally rotate the activity by a given angle and/or filter the data. Then, we'll generate the heatmap as a sparse matrix. Following that, we'll convert the matrix to RGB values, convert it to json and inject it into a HTML template. Quite a few nested function calls, right? Wait to see them in action: (defn strava-heatmap [file] (html/save-file (html/generate-html (heatmap/map-to-json (heatmap/map-to-rgb (heatmap/heatmap-matrix (heatmap/normalize-trkpts (gpx/xml-to-trkpts (gpx/read-file-as-string file))))))) (str \"out/\" (UUID/randomUUID) \".html\"))) Now, let's re-write it using the threading macros: we'll start from the GPX file we exported from Strava and thread the result of each step as the last argument of the next function: (defn strava-heatmap [file] (->> file gpx/read-file-as-string gpx/xml-to-trkpts heatmap/normalize-trkpts heatmap/heatmap-matrix heatmap/map-to-rgb heatmap/map-to-json html/generate-html (html/save-file (str \"out/\" (UUID/randomUUID) \".html\")))) Pretty neat, isn't it? Let's add a step to rotate the activity counter-clockwise by 55 degrees, because I want the heatmap to be aligned with the pitch of the field, rather than the North-South axis. Additionally, let's remove the track points with a cadence of less than 10 steps per minute (filtering out epic failures as a goalkeeper): (defn strava-heatmap [file] (->> file gpx/read-file-as-string gpx/xml-to-trkpts (filter (fn[pt] (> (:cadence pt) 10))) ;; <- filter by cadence heatmap/normalize-trkpts-precision (heatmap/rotate-points -55) ;; <- rotate counter-clockwise by 55 degrees heatmap/heatmap-matrix heatmap/map-to-rgb heatmap/map-to-json html/generate-html (html/save-file (str \"out/\" (UUID/randomUUID) \".html\")))) As we can see, it's much easier to add new steps to the pipeline. I also like the fact that you don't really need to know Clojure to be able to read this flow. Beyond readability, functional pipelines offer significant practical benefits: each transformation step is isolated and testable, making debugging easier since we can inspect the output at any stage. Additionally, pipeline steps can be easily reordered, combined, or parallelized without affecting other parts of the system. What About Java? What does this remind you of from Java? And why the Stream API? Some fluent APIs from Java are inspired from functional programming. That's why we can find similar patterns in the Stream API, reactive pipelines... and even CompletableFuture! Jus for fun, let's imagine we wrote this in Java, using the CompletableFuture API (this is how the code can look like): public CompletableFuture<Path> stravaHeatmap(String file) { return CompletableFuture .supplyAsync(() -> gpx.readFileAsString(file)) .thenApply(xml -> gpx.xmlToTrkpts(xml)) .thenApply(pts -> pts.stream() .filter(pt -> pt.cadence() > 10).toList()) .thenApply(pts -> heatmap.normalizeTrkptsPrecision(pts)) .thenApply(pts -> heatmap.rotatePoints(pts, -55)) .thenApply(map -> heatmap.heatmapMatrix(map)) .thenApply(map -> heatmap.mapToRgb(map)) .thenApply(rgb -> heatmap.mapToJson(rgb)) .thenApply(json -> htmlUtil.generateHtml(json)) .thenApply(html -> htmlUtil.saveFile( \"out/%s.html\".frormatted(UUID.randomUUID())), html); } Needless to say, the Clojure version is much easier to read and reason about. The threading pattern we see in Clojure aligns perfectly with Data-Oriented Programming (DOP), a paradigm gaining traction in Java. DOP emphasizes treating data as immutable and flowing it through a series of transformations, rather than encapsulating it within objects. This approach naturally benefits from threading operators because data transformations become explicit pipeline steps. If you want to read more about DOP, check out this article Conclusion In this shoer article, we discussed Clojure's threading macros. One of those simple features that make a huge difference in how you write and think about code. Whether you're working in Clojure or dreaming of better Java syntax, the pattern is worth understanding. Do you think we'll ever get a threading operator in Java?","title":"Clojure Threading for Dummy Java Devs (such as myself)"},{"location":"blog/clojure-threading/#clojure-threading-for-dummy-java-devs-such-as-myself","text":"Published: August 30, 2025 #clojure #java #functional programming Recently, I've been playing around with Clojure. I wanted to take advantage of the AI tools available to explore a new language... and not just Kotlin or Python, but something completely new to me. One of the features that caught my attention was the threading macros ( -> and ->> ) it's a pretty simple feature, but I found it interesting and elegant.","title":"Clojure Threading for Dummy Java Devs (such as myself)"},{"location":"blog/clojure-threading/#strava-heatmaps","text":"A few words about the project I've built in Clojure? Well, I'm recording all my sport activities using my Garmin watch, even when I'm playing football. When I get home and download my activity, the map looks something like the spaghetti code I generate when vibe-coding with ChatGPT: Needless to say, I want to visualize my football session a bit better. so I decided to build a small app to export this activity as a GPX file and generate an HTML heatmap based on it. After applying all these steps, we'll expect a heatmap like this: Basically, we need to: parse the GPX file (GPX is an XML schema designed as a common GPS data) normalize the data (optionally) rotate the activity by a given angle (optionally) filter the data - for eg.: by running cadence generate the heatmap generate the HTML file A functional language sounded like a perfect fit for implementing this pipeline of operations, so I decided to give Clojure a try. Before diving into the threading macros that make these pipelines so elegant, let's cover some Clojure basics. If you're coming from Java like me, the syntax might look intimidating at first, but the core concepts are actually quite straightforward once you get the hang of the parentheses.","title":"Strava Heatmaps"},{"location":"blog/clojure-threading/#clojure-syntax","text":"Let me show you what I understood about Clojure so far. The syntax follows a consistent pattern: (function-name arguments...) where the function always comes first inside the parentheses, followed by its arguments. For example, if we want to add two numbers (say 1 and 2) , we would write: ( + 1 2 ) . This is because + is the addition function, followed by 1 and 2 - the numbers being added. We can define a function using the defn keyword, followed by the function name, its arguments, and the body of the function. Let's write a function that adds two numbers, received as arguments: (defn add [a b] (+ a b)) Similarly, when we want to compare numbers, we'll start with the comparison function, followed by the numbers to compare. For instance, this is how we verify if two numbers (a and b) are equal: ( = a b ) Now let's write a unit test for our add function: (deftest add-two-test (is (= 3 (add 1 2) ) ) ) ;; or simply: (deftest add-two-test (is (= 3 (add 1 2))))","title":"Clojure Syntax"},{"location":"blog/clojure-threading/#the-threading-macros","text":"Look at our test: as simple as it is, it already has quite a few nested function calls. If we read it from right to left, we can see that we're: adding 1 and 2 comparing the result with 3 verifying if the result is true When it comes to pipelines of operations, the threading macros ( -> and ->> ) allows us to take the result of one operation and pass it as argument to the next operation. The difference between the two is that -> ( aka thread-first ) passes the value to the next function as the first argument, while ->> ( aka thread-last ) passes the value as the last argument. Therefore, we can re-write our test as follows: (deftest add-two-test-x (->> 1 (add 2) (= 3) (is))) And it reads like this: we start with the number 1, then we add 2 to it, then we compare the result with 3, and finally we verify if the new result is true. Of course, this is a very simple example, but it shows the power of the threading macros. Let's go back to our heatmap pipeline: As discussed, we'll start with a GPX file that we need to read as text. Then, we'll parse its content and normalize the data. At this point, we can optionally rotate the activity by a given angle and/or filter the data. Then, we'll generate the heatmap as a sparse matrix. Following that, we'll convert the matrix to RGB values, convert it to json and inject it into a HTML template. Quite a few nested function calls, right? Wait to see them in action: (defn strava-heatmap [file] (html/save-file (html/generate-html (heatmap/map-to-json (heatmap/map-to-rgb (heatmap/heatmap-matrix (heatmap/normalize-trkpts (gpx/xml-to-trkpts (gpx/read-file-as-string file))))))) (str \"out/\" (UUID/randomUUID) \".html\"))) Now, let's re-write it using the threading macros: we'll start from the GPX file we exported from Strava and thread the result of each step as the last argument of the next function: (defn strava-heatmap [file] (->> file gpx/read-file-as-string gpx/xml-to-trkpts heatmap/normalize-trkpts heatmap/heatmap-matrix heatmap/map-to-rgb heatmap/map-to-json html/generate-html (html/save-file (str \"out/\" (UUID/randomUUID) \".html\")))) Pretty neat, isn't it? Let's add a step to rotate the activity counter-clockwise by 55 degrees, because I want the heatmap to be aligned with the pitch of the field, rather than the North-South axis. Additionally, let's remove the track points with a cadence of less than 10 steps per minute (filtering out epic failures as a goalkeeper): (defn strava-heatmap [file] (->> file gpx/read-file-as-string gpx/xml-to-trkpts (filter (fn[pt] (> (:cadence pt) 10))) ;; <- filter by cadence heatmap/normalize-trkpts-precision (heatmap/rotate-points -55) ;; <- rotate counter-clockwise by 55 degrees heatmap/heatmap-matrix heatmap/map-to-rgb heatmap/map-to-json html/generate-html (html/save-file (str \"out/\" (UUID/randomUUID) \".html\")))) As we can see, it's much easier to add new steps to the pipeline. I also like the fact that you don't really need to know Clojure to be able to read this flow. Beyond readability, functional pipelines offer significant practical benefits: each transformation step is isolated and testable, making debugging easier since we can inspect the output at any stage. Additionally, pipeline steps can be easily reordered, combined, or parallelized without affecting other parts of the system.","title":"The Threading Macros"},{"location":"blog/clojure-threading/#what-about-java","text":"What does this remind you of from Java? And why the Stream API? Some fluent APIs from Java are inspired from functional programming. That's why we can find similar patterns in the Stream API, reactive pipelines... and even CompletableFuture! Jus for fun, let's imagine we wrote this in Java, using the CompletableFuture API (this is how the code can look like): public CompletableFuture<Path> stravaHeatmap(String file) { return CompletableFuture .supplyAsync(() -> gpx.readFileAsString(file)) .thenApply(xml -> gpx.xmlToTrkpts(xml)) .thenApply(pts -> pts.stream() .filter(pt -> pt.cadence() > 10).toList()) .thenApply(pts -> heatmap.normalizeTrkptsPrecision(pts)) .thenApply(pts -> heatmap.rotatePoints(pts, -55)) .thenApply(map -> heatmap.heatmapMatrix(map)) .thenApply(map -> heatmap.mapToRgb(map)) .thenApply(rgb -> heatmap.mapToJson(rgb)) .thenApply(json -> htmlUtil.generateHtml(json)) .thenApply(html -> htmlUtil.saveFile( \"out/%s.html\".frormatted(UUID.randomUUID())), html); } Needless to say, the Clojure version is much easier to read and reason about. The threading pattern we see in Clojure aligns perfectly with Data-Oriented Programming (DOP), a paradigm gaining traction in Java. DOP emphasizes treating data as immutable and flowing it through a series of transformations, rather than encapsulating it within objects. This approach naturally benefits from threading operators because data transformations become explicit pipeline steps. If you want to read more about DOP, check out this article","title":"What About Java?"},{"location":"blog/clojure-threading/#conclusion","text":"In this shoer article, we discussed Clojure's threading macros. One of those simple features that make a huge difference in how you write and think about code. Whether you're working in Clojure or dreaming of better Java syntax, the pattern is worth understanding. Do you think we'll ever get a threading operator in Java?","title":"Conclusion"},{"location":"blog/java-optional-vs-kotlin/","text":"Java's Optional vs Kotlin: Side by Side Published: July 16, 2023 #java #kotlin #functional programming In a previous article, we compared Java's syntax to Clojure's threading operators . Today, we'll explore another comparison: how Java's Optional and Kotlin's nullable types handle null values. It's worth noting a fundamental philosophical difference between these approaches: Kotlin treats nullable types as first-class citizens built directly into the type system. On the other hand, Java's Optional is a wrapper class added later to address nullability concerns. In this short article, we'll explore the similarities and differences between the two approaches, highlighting their benefits and use cases. Getting the Value Let's start by comparing how Java's Optional and Kotlin handle value extraction or exception throwing. In Java, the Optional class initially provided the get() method for this purpose, but later introduced orElseThrow() to emphasize the possibility of an exception: // java Optional<String> optionalValue = Optional.of(\"dummy\"); String value = optionalValue.orElseThrow(); In contrast, Kotlin utilizes the double bang ( !! ) operator for similar functionality: // kotlin val optionalValue: String? = \"dummy\" val value: String = optionalValue!! The API of the Optional class allows us to provide a custom exception if the object is empty. Let's look at the orElseThrow(Supplier ) and its Kotlin equivalent, the Elvis Operator ( ?: ): // java Optional<String> optionalValue = Optional.empty(); String value = optionalValue.orElseThrow( () -> new IllegalStateException(\"Oupps!\")); // kotlin val optionalValue: String? = null val value = optionalValue ?: throw IllegalStateException(\"Oupps!\") Default Values Kotlin's \"Elvis\" operator also allows us to provide a default value that will be used if the variable is null. In Java, this functionality can be achieved through the method orElse() : // java Optional<String> optionalValue = Optional.empty(); String value = optionalValue.orElse(\"default\"); // kotlin val optionalValue: String? = null val value = optionalValue ?: \"default\" Map() and FlatMap() In a future article, we'll discuss how Java's Optional embraces the concepts of functors and monads through the implementation of its map() and flatMap() . These methods allow us to transform the value inside the Optional , without touching the \"container\" itself. // java Optional<String> optionalValue = Optional.of(\"dummy\"); Optional<Integer> length = optionalValue.map(String::length); Optional<Account> account = Optional.ofNullable(dummyAccount); Optional<Address> address = account.flatMap(Account::address); Optional<String> street = address.flatMap(Address::street); On the other hand, in Kotlin, this will be achieved through the method let() : // kotlin val optionalValue: String? = \"dummy\" val length: Int? = optionalValue?.let { it.length } val account: Account? = dummyAccount val address: Address? = account?.let { it.address } val street: String? = address?.let { it.street } While let() works, it's not the most idiomatic Kotlin. When traversing an object with multiple nullable fields and leveraging the power of map() or flatMap() , Kotlin provides more concise approach, via ?. : // kotlin val street: String = account?.address?.street?: \"unkown\" // java String street = Optional.ofNullable(account) .flatMap(Account::address) .flatMap(Address::street) .orElse(\"unkown\"); Using the Value if Present Lastly, Optional 's ifPresent() allows us to provide a Consumer function that will be executed only if the value is present. Moreover, the method ifPresentOrElse() allows us to provide an additional function that will be invoked if the object is empty. // java Optional<String> optionalValue = Optional.of(\"dummy\"); optionalValue.ifPresent(value -> System.out.println(value)); optionalValue.ifPresentOrElse( value -> System.out.println(value), () -> System.out.println(\"Empty\") ); Let's see how we can achieve the same functionality in Kotlin: // kotlin val optionalValue: String? = \"dummy\" optionalValue?.let { println(it) } optionalValue ?.let { println(it) } ?: run { println(\"Empty\") } Conclusion In conclusion, using Kotlin operators like ?. and ?: enable cleaner and more concise code for handling nullable values. While more verbose, Java's Optional provides an explicit approach to null-handling that integrates with existing code, addressing nullability concerns without breaking backwards compatibility. The key takeaway is that both languages recognize the importance of explicit null handling, and provide robust mechanisms to prevent null pointer exceptions while making the code's intent clear to other developers.","title":"Java's Optional vs Kotlin: Side by Side"},{"location":"blog/java-optional-vs-kotlin/#javas-optional-vs-kotlin-side-by-side","text":"Published: July 16, 2023 #java #kotlin #functional programming In a previous article, we compared Java's syntax to Clojure's threading operators . Today, we'll explore another comparison: how Java's Optional and Kotlin's nullable types handle null values. It's worth noting a fundamental philosophical difference between these approaches: Kotlin treats nullable types as first-class citizens built directly into the type system. On the other hand, Java's Optional is a wrapper class added later to address nullability concerns. In this short article, we'll explore the similarities and differences between the two approaches, highlighting their benefits and use cases.","title":"Java's Optional vs Kotlin: Side by Side"},{"location":"blog/java-optional-vs-kotlin/#getting-the-value","text":"Let's start by comparing how Java's Optional and Kotlin handle value extraction or exception throwing. In Java, the Optional class initially provided the get() method for this purpose, but later introduced orElseThrow() to emphasize the possibility of an exception: // java Optional<String> optionalValue = Optional.of(\"dummy\"); String value = optionalValue.orElseThrow(); In contrast, Kotlin utilizes the double bang ( !! ) operator for similar functionality: // kotlin val optionalValue: String? = \"dummy\" val value: String = optionalValue!! The API of the Optional class allows us to provide a custom exception if the object is empty. Let's look at the orElseThrow(Supplier ) and its Kotlin equivalent, the Elvis Operator ( ?: ): // java Optional<String> optionalValue = Optional.empty(); String value = optionalValue.orElseThrow( () -> new IllegalStateException(\"Oupps!\")); // kotlin val optionalValue: String? = null val value = optionalValue ?: throw IllegalStateException(\"Oupps!\")","title":"Getting the Value"},{"location":"blog/java-optional-vs-kotlin/#default-values","text":"Kotlin's \"Elvis\" operator also allows us to provide a default value that will be used if the variable is null. In Java, this functionality can be achieved through the method orElse() : // java Optional<String> optionalValue = Optional.empty(); String value = optionalValue.orElse(\"default\"); // kotlin val optionalValue: String? = null val value = optionalValue ?: \"default\"","title":"Default Values"},{"location":"blog/java-optional-vs-kotlin/#map-and-flatmap","text":"In a future article, we'll discuss how Java's Optional embraces the concepts of functors and monads through the implementation of its map() and flatMap() . These methods allow us to transform the value inside the Optional , without touching the \"container\" itself. // java Optional<String> optionalValue = Optional.of(\"dummy\"); Optional<Integer> length = optionalValue.map(String::length); Optional<Account> account = Optional.ofNullable(dummyAccount); Optional<Address> address = account.flatMap(Account::address); Optional<String> street = address.flatMap(Address::street); On the other hand, in Kotlin, this will be achieved through the method let() : // kotlin val optionalValue: String? = \"dummy\" val length: Int? = optionalValue?.let { it.length } val account: Account? = dummyAccount val address: Address? = account?.let { it.address } val street: String? = address?.let { it.street } While let() works, it's not the most idiomatic Kotlin. When traversing an object with multiple nullable fields and leveraging the power of map() or flatMap() , Kotlin provides more concise approach, via ?. : // kotlin val street: String = account?.address?.street?: \"unkown\" // java String street = Optional.ofNullable(account) .flatMap(Account::address) .flatMap(Address::street) .orElse(\"unkown\");","title":"Map() and FlatMap()"},{"location":"blog/java-optional-vs-kotlin/#using-the-value-if-present","text":"Lastly, Optional 's ifPresent() allows us to provide a Consumer function that will be executed only if the value is present. Moreover, the method ifPresentOrElse() allows us to provide an additional function that will be invoked if the object is empty. // java Optional<String> optionalValue = Optional.of(\"dummy\"); optionalValue.ifPresent(value -> System.out.println(value)); optionalValue.ifPresentOrElse( value -> System.out.println(value), () -> System.out.println(\"Empty\") ); Let's see how we can achieve the same functionality in Kotlin: // kotlin val optionalValue: String? = \"dummy\" optionalValue?.let { println(it) } optionalValue ?.let { println(it) } ?: run { println(\"Empty\") }","title":"Using the Value if Present"},{"location":"blog/java-optional-vs-kotlin/#conclusion","text":"In conclusion, using Kotlin operators like ?. and ?: enable cleaner and more concise code for handling nullable values. While more verbose, Java's Optional provides an explicit approach to null-handling that integrates with existing code, addressing nullability concerns without breaking backwards compatibility. The key takeaway is that both languages recognize the importance of explicit null handling, and provide robust mechanisms to prevent null pointer exceptions while making the code's intent clear to other developers.","title":"Conclusion"},{"location":"blog/less-mocks-more-functions/","text":"Less Mocks, More Functions! Published: September 28, 2025 #functional programming #design #testing #java After playing with Clojure , I was amazed by how testable everything is in the functional world. In this article, we'll explore a technique that uses functional interfaces to reduce the number of mocks needed for testing. I started thinking about incorporating some functional techniques into my Java development work - without shaking up the codebase too much or becoming \"that functional programming person\" colleagues avoid at the water cooler. The main idea is simple: extract dependencies that produce side effects and move them outside of the component you want to test . The Problem This technique is particularly effective when the tested component relies on a dependency but utilizes only a select few of its methods, ideally just one. We'll use Java for the code examples in the article, but the approach can be applied regardless of the language or testing frameworks. Let's start with a typical example: class AccountService { private final AccountRepository repository; AccountService(AccountRepository repository) { this.repository = repository; } void register(String name, String email) { var uuid = UUID.randomUUID(); var account = new Account(uuid.toString(), name, email); // some business logic repository.save(account); } } To test this without connecting to a database, we need to mock the repository: @Test void testWithMocks() { var repository = mock(AccountRepository.class); var service = new AccountService(repository); service.register(\"john doe\", \"jd@yahoo.com\"); verify(repository).save(argThat(it -> it.name().equals(\"john doe\") && it.email().equals(\"jd@yahoo.com\") && it.id() != null )); } Using Functions for Side Effects If we think about it, we only need a mock because AccountService::register produces side effects (saving the Account into the database). Another obvious problem with our design is that we depend on the whole AccountRepository class even though we only use its save() method. Simply put, our class needs a function that accepts an Account and saves it. The signature of this function would be (Account) -> void . In Java, this function is also known as Consumer<Account> . So, let's change AccountService and make it depend on this function instead of holding the whole repository: class AccountService { private final Consumer<Account> saveAccount; AccountService(Consumer<Account> saveAccount) { this.saveAccount = saveAccount; } // Maintain backwards compatibility @Autowired AccountService(AccountRepository repository) { this(repository::save); } void register(String name, String email) { var uuid = UUID.randomUUID(); var account = new Account(uuid.toString(), name, email); // some business logic saveAccount.accept(account); } } Testing Becomes Fun Now testing becomes much simpler: @Test void testWithLambdas() { List<Account> savedAccounts = new ArrayList<>(); var service = new AccountService(savedAccounts::add); service.register(\"john doe\", \"jd@yahoo.com\"); assertThat(savedAccounts) .hasSize(1).first() .hasFieldOrPropertyWithValue(\"name\", \"john doe\") .hasFieldOrPropertyWithValue(\"email\", \"jd@yahoo.com\") .hasFieldOrProperty(\"id\"); } Testing exceptions is equally straightforward: @Test void testWithLambdas_exceptions() { var service = new AccountService(__ -> { throw new IllegalArgumentException(\"test exception\"); }); assertThatThrownBy(() -> service.register(\"john doe\", \"jd@yahoo.com\")) .isInstanceOf(IllegalArgumentException.class); } Handling Static Dependencies Our code still isn't \"pure\" because it calls UUID.randomUUID() . We can apply the same technique here by extracting the UUID generation: class AccountService { private final Consumer<Account> saveAccount; private final Supplier<UUID> generateUuid; AccountService(Consumer<Account> saveAccount, Supplier<UUID> generateUuid) { this.saveAccount = saveAccount; this.generateUuid = generateUuid; } // Backwards compatibility @Autowired AccountService(AccountRepository repository) { this(repository::save, UUID::randomUUID); } void register(String name, String email) { var uuid = generateUuid.get(); var account = new Account(uuid.toString(), name, email); // some business logic saveAccount.accept(account); } } Now our tests are completely deterministic: @Test void testWithLambdas() { List<Account> savedAccounts = new ArrayList<>(); var service = new AccountService( savedAccounts::add, () -> UUID.fromString(\"00000000-0000-0000-0000-000000000001\") ); service.register(\"john doe\", \"jd@yahoo.com\"); assertThat(savedAccounts) .hasSize(1).first() .hasFieldOrPropertyWithValue(\"name\", \"john doe\") .hasFieldOrPropertyWithValue(\"email\", \"jd@yahoo.com\") .hasFieldOrPropertyWithValue(\"id\", \"00000000-0000-0000-0000-000000000001\"); } Conclusion By extracting side effects into functions, we've made our code: \u2705 Easier to test - no mocks needed \u2705 More focused - our components only depends on what it actually needs \u2705 Backwards compatible - existing code continues to work This technique aligns with SOLID principles (specifically Interface Segregation and Dependency Inversion) while borrowing useful concepts from functional programming. The result is cleaner, more testable code that's easier to reason about.","title":"Less Mocks, More Functions!"},{"location":"blog/less-mocks-more-functions/#less-mocks-more-functions","text":"Published: September 28, 2025 #functional programming #design #testing #java After playing with Clojure , I was amazed by how testable everything is in the functional world. In this article, we'll explore a technique that uses functional interfaces to reduce the number of mocks needed for testing. I started thinking about incorporating some functional techniques into my Java development work - without shaking up the codebase too much or becoming \"that functional programming person\" colleagues avoid at the water cooler. The main idea is simple: extract dependencies that produce side effects and move them outside of the component you want to test .","title":"Less Mocks, More Functions!"},{"location":"blog/less-mocks-more-functions/#the-problem","text":"This technique is particularly effective when the tested component relies on a dependency but utilizes only a select few of its methods, ideally just one. We'll use Java for the code examples in the article, but the approach can be applied regardless of the language or testing frameworks. Let's start with a typical example: class AccountService { private final AccountRepository repository; AccountService(AccountRepository repository) { this.repository = repository; } void register(String name, String email) { var uuid = UUID.randomUUID(); var account = new Account(uuid.toString(), name, email); // some business logic repository.save(account); } } To test this without connecting to a database, we need to mock the repository: @Test void testWithMocks() { var repository = mock(AccountRepository.class); var service = new AccountService(repository); service.register(\"john doe\", \"jd@yahoo.com\"); verify(repository).save(argThat(it -> it.name().equals(\"john doe\") && it.email().equals(\"jd@yahoo.com\") && it.id() != null )); }","title":"The Problem"},{"location":"blog/less-mocks-more-functions/#using-functions-for-side-effects","text":"If we think about it, we only need a mock because AccountService::register produces side effects (saving the Account into the database). Another obvious problem with our design is that we depend on the whole AccountRepository class even though we only use its save() method. Simply put, our class needs a function that accepts an Account and saves it. The signature of this function would be (Account) -> void . In Java, this function is also known as Consumer<Account> . So, let's change AccountService and make it depend on this function instead of holding the whole repository: class AccountService { private final Consumer<Account> saveAccount; AccountService(Consumer<Account> saveAccount) { this.saveAccount = saveAccount; } // Maintain backwards compatibility @Autowired AccountService(AccountRepository repository) { this(repository::save); } void register(String name, String email) { var uuid = UUID.randomUUID(); var account = new Account(uuid.toString(), name, email); // some business logic saveAccount.accept(account); } }","title":"Using Functions for Side Effects"},{"location":"blog/less-mocks-more-functions/#testing-becomes-fun","text":"Now testing becomes much simpler: @Test void testWithLambdas() { List<Account> savedAccounts = new ArrayList<>(); var service = new AccountService(savedAccounts::add); service.register(\"john doe\", \"jd@yahoo.com\"); assertThat(savedAccounts) .hasSize(1).first() .hasFieldOrPropertyWithValue(\"name\", \"john doe\") .hasFieldOrPropertyWithValue(\"email\", \"jd@yahoo.com\") .hasFieldOrProperty(\"id\"); } Testing exceptions is equally straightforward: @Test void testWithLambdas_exceptions() { var service = new AccountService(__ -> { throw new IllegalArgumentException(\"test exception\"); }); assertThatThrownBy(() -> service.register(\"john doe\", \"jd@yahoo.com\")) .isInstanceOf(IllegalArgumentException.class); }","title":"Testing Becomes Fun"},{"location":"blog/less-mocks-more-functions/#handling-static-dependencies","text":"Our code still isn't \"pure\" because it calls UUID.randomUUID() . We can apply the same technique here by extracting the UUID generation: class AccountService { private final Consumer<Account> saveAccount; private final Supplier<UUID> generateUuid; AccountService(Consumer<Account> saveAccount, Supplier<UUID> generateUuid) { this.saveAccount = saveAccount; this.generateUuid = generateUuid; } // Backwards compatibility @Autowired AccountService(AccountRepository repository) { this(repository::save, UUID::randomUUID); } void register(String name, String email) { var uuid = generateUuid.get(); var account = new Account(uuid.toString(), name, email); // some business logic saveAccount.accept(account); } } Now our tests are completely deterministic: @Test void testWithLambdas() { List<Account> savedAccounts = new ArrayList<>(); var service = new AccountService( savedAccounts::add, () -> UUID.fromString(\"00000000-0000-0000-0000-000000000001\") ); service.register(\"john doe\", \"jd@yahoo.com\"); assertThat(savedAccounts) .hasSize(1).first() .hasFieldOrPropertyWithValue(\"name\", \"john doe\") .hasFieldOrPropertyWithValue(\"email\", \"jd@yahoo.com\") .hasFieldOrPropertyWithValue(\"id\", \"00000000-0000-0000-0000-000000000001\"); }","title":"Handling Static Dependencies"},{"location":"blog/less-mocks-more-functions/#conclusion","text":"By extracting side effects into functions, we've made our code: \u2705 Easier to test - no mocks needed \u2705 More focused - our components only depends on what it actually needs \u2705 Backwards compatible - existing code continues to work This technique aligns with SOLID principles (specifically Interface Segregation and Dependency Inversion) while borrowing useful concepts from functional programming. The result is cleaner, more testable code that's easier to reason about.","title":"Conclusion"},{"location":"blog/lombok-lazy-oop/","text":"Lombok's \"Lazy\" Magic and the O.O.P. Alternative Published: February 12, 2023 #design #oop Overview In this article, we'll tackle a widespread issue: the usage of convoluted logic in constructors . We'll then demonstrate how this can be remedied with Lombok's lazy loading feature. Lastly, we'll contrast Lombok's solution with its object-oriented programming counterpart: the decorator pattern. For the code examples in this article, we'll use the Employee class that has two final fields: the employee name and the salary. The employee name is passed as a parameter during object construction, while the salary is determined through a potentially time-consuming calculation. This calculation could involve a complex mathematical formula or a network call, for example: class Employee { private final String name; private final BigDecimal salary; public Employee(String name) { this.name = name; this.salary = calculateSalary(); } // slow operation static BigDecimal calculateSalary() { /* ... */ } // ... } Though, there is a design smell in the code snippet above. Namely, we should avoid performing heavy operations inside the constructor: the construction of the object should be rather fast . Lombok's \"Lazy\" Magic To ensure efficient salary calculation, one approach is to utilize Lombok's @Getter(lazy = true) . This annotation provides a convenient way to calculate the salary only once and cache its value for future reference : class Employee { private final String name; // constructor @Getter(lazy = true) private final BigDecimal salary = calculateSalary(); // ... } Not only does this approach enhance performance, but it also improves the design of our code. By calculating the salary only when it is first accessed, instead of in the constructor, the code becomes more flexible and efficient: @Test void test() { log.info(\"test started\"); var employee = new Employee(\"john doe\"); log.info(\"employee created!\"); var s = employee.getSalary(); log.info(\"salary retrieved: \" + s); s = employee.getSalary(); log.info(\"salary retrieved: \" + s); s = employee.getSalary(); log.info(\"salary retrieved: \" + s); } Assuming the calculateSalary() method involves I/O and takes a long time, we'd want following behavior from our lazy getter: a fast constructor; a slow initial evaluation of the salary; fast subsequent evaluations; As expected, the constructor is fast and the first retrieval of the salary is slow: after that, the value is cached and everything goes fast. The O.O.P. Alternative While the use of the lazy getter has its advantages, it also introduces an element of 'magic' into our code. It's important to consider the trade-offs and weigh the benefits against the potential consequences. This time, we can achieve the same functionality by applying the \"decorator\" design pattern. Firstly, let's revert to the initial version of the Employee class: class Employee { private final String name; // constructor private BigDecimal getSalary() { return calculateSalary(); } // slow operation static BigDecimal calculateSalary() { /* ... */ } //... } Now, let's create a very simple implementation of an EmployeeWithCachedSalary class that extends Employee and wraps the original instance. We do not have a common interface to implement, and, for this simple use case, we won't overcomplicate the example: class EmployeeWithCachedSalary extends Employee { private final AtomicReference<BigDecimal> cachedSalary = new AtomicReference<>(); private final Employee delegate; // constructor @Override public BigDecimal getSalary() { return cachedSalary.updateAndGet( salary -> salary != null ? salary : delegate.getSalary() ); } // any other method calls will be delegated // to the decorated Employee instance: @Override public String getName() { return delegate.getName(); } } As we can see, when overriding the getSalary() method, we use an AtomicReference to check if the salary has already been computed. This approach has the advantage of extracting the logic about caching the salary value away from the Employee class , giving us more flexibility. In order to use this decorator, we'll create a new instance of EmployeeWithCachedSalary wrapping the original Employee object: @Test void test() { log.info(\"test started\"); Employee employee = new EmployeeWithCachedSalary(new Employee()); log.info(\"employee created!\"); BigDecimal salary = employee.getSalary(); log.info(\"salary retrieved: \" + s); salary = employee.getSalary(); log.info(\"salary retrieved: \" + s); salary = employee.getSalary(); log.info(\"salary retrieved: \" + s); } Conclusion In this short article, we delved into the @Getter(lazy = true) feature of Lombok, starting with a discussion on the issue it aims to address \u2014 the negative impacts of incorporating complex logic within constructors. We then showcased how Lombok comes to the rescue, followed by a presentation of the object-oriented programming alternative, the Decorator Pattern.","title":"Lombok's \"Lazy\" Magic and the O.O.P. Alternative"},{"location":"blog/lombok-lazy-oop/#lomboks-lazy-magic-and-the-oop-alternative","text":"Published: February 12, 2023 #design #oop","title":"Lombok's \"Lazy\" Magic and the O.O.P. Alternative"},{"location":"blog/lombok-lazy-oop/#overview","text":"In this article, we'll tackle a widespread issue: the usage of convoluted logic in constructors . We'll then demonstrate how this can be remedied with Lombok's lazy loading feature. Lastly, we'll contrast Lombok's solution with its object-oriented programming counterpart: the decorator pattern. For the code examples in this article, we'll use the Employee class that has two final fields: the employee name and the salary. The employee name is passed as a parameter during object construction, while the salary is determined through a potentially time-consuming calculation. This calculation could involve a complex mathematical formula or a network call, for example: class Employee { private final String name; private final BigDecimal salary; public Employee(String name) { this.name = name; this.salary = calculateSalary(); } // slow operation static BigDecimal calculateSalary() { /* ... */ } // ... } Though, there is a design smell in the code snippet above. Namely, we should avoid performing heavy operations inside the constructor: the construction of the object should be rather fast .","title":"Overview"},{"location":"blog/lombok-lazy-oop/#lomboks-lazy-magic","text":"To ensure efficient salary calculation, one approach is to utilize Lombok's @Getter(lazy = true) . This annotation provides a convenient way to calculate the salary only once and cache its value for future reference : class Employee { private final String name; // constructor @Getter(lazy = true) private final BigDecimal salary = calculateSalary(); // ... } Not only does this approach enhance performance, but it also improves the design of our code. By calculating the salary only when it is first accessed, instead of in the constructor, the code becomes more flexible and efficient: @Test void test() { log.info(\"test started\"); var employee = new Employee(\"john doe\"); log.info(\"employee created!\"); var s = employee.getSalary(); log.info(\"salary retrieved: \" + s); s = employee.getSalary(); log.info(\"salary retrieved: \" + s); s = employee.getSalary(); log.info(\"salary retrieved: \" + s); } Assuming the calculateSalary() method involves I/O and takes a long time, we'd want following behavior from our lazy getter: a fast constructor; a slow initial evaluation of the salary; fast subsequent evaluations; As expected, the constructor is fast and the first retrieval of the salary is slow: after that, the value is cached and everything goes fast.","title":"Lombok's \"Lazy\" Magic"},{"location":"blog/lombok-lazy-oop/#the-oop-alternative","text":"While the use of the lazy getter has its advantages, it also introduces an element of 'magic' into our code. It's important to consider the trade-offs and weigh the benefits against the potential consequences. This time, we can achieve the same functionality by applying the \"decorator\" design pattern. Firstly, let's revert to the initial version of the Employee class: class Employee { private final String name; // constructor private BigDecimal getSalary() { return calculateSalary(); } // slow operation static BigDecimal calculateSalary() { /* ... */ } //... } Now, let's create a very simple implementation of an EmployeeWithCachedSalary class that extends Employee and wraps the original instance. We do not have a common interface to implement, and, for this simple use case, we won't overcomplicate the example: class EmployeeWithCachedSalary extends Employee { private final AtomicReference<BigDecimal> cachedSalary = new AtomicReference<>(); private final Employee delegate; // constructor @Override public BigDecimal getSalary() { return cachedSalary.updateAndGet( salary -> salary != null ? salary : delegate.getSalary() ); } // any other method calls will be delegated // to the decorated Employee instance: @Override public String getName() { return delegate.getName(); } } As we can see, when overriding the getSalary() method, we use an AtomicReference to check if the salary has already been computed. This approach has the advantage of extracting the logic about caching the salary value away from the Employee class , giving us more flexibility. In order to use this decorator, we'll create a new instance of EmployeeWithCachedSalary wrapping the original Employee object: @Test void test() { log.info(\"test started\"); Employee employee = new EmployeeWithCachedSalary(new Employee()); log.info(\"employee created!\"); BigDecimal salary = employee.getSalary(); log.info(\"salary retrieved: \" + s); salary = employee.getSalary(); log.info(\"salary retrieved: \" + s); salary = employee.getSalary(); log.info(\"salary retrieved: \" + s); }","title":"The O.O.P. Alternative"},{"location":"blog/lombok-lazy-oop/#conclusion","text":"In this short article, we delved into the @Getter(lazy = true) feature of Lombok, starting with a discussion on the issue it aims to address \u2014 the negative impacts of incorporating complex logic within constructors. We then showcased how Lombok comes to the rescue, followed by a presentation of the object-oriented programming alternative, the Decorator Pattern.","title":"Conclusion"},{"location":"blog/micrometer-assertions-contribution/","text":"My First Contribution to Micrometer Published: January 13, 2026 #testing #oss #observability I'm excited to share that my first contribution to the Micrometer project has been merged and is now available in the 1.17.0-M1 pre-release ! The contribution adds AssertJ-style assertions for various meter types, making metric testing fun. Testing Without micrometer-test Recently, I wrote a Baeldung article on Testing with Micrometer , where we went over a few of the basics. Without Micrometer's test support module, we can rely on the MeterRegistry to fetch various meters and assert their values manually. For example, this is how we could verify that a counter has been incremented correctly: class MicrometerUnitTest { MeterRegistry meterRegistry = new SimpleMeterRegistry(); FooService fooService = new FooService(meterRegistry); @Test void whenFooIsCalled_thenCounterIsIncremented() { fooService.foo(); fooService.foo(); fooService.foo(); double invocations = meterRegistry.get(\"foo.count\") .counter() .count(); assertThat(invocations) .isEqualTo(3); } } My Contribution - Meter Assertions The good news is that Micrometer provides a dedicated test support module: <dependency> <groupId>io.micrometer</groupId> <artifactId>micrometer-test</artifactId> <version>1.17.0-M1</version> <scope>test</scope> </dependency> The micrometer-test was available for some time, but it was only covering a few basic assertions, such as checking the existence of a meter. With my contribution, we can now use the same fluent-api we know and love, for asserting meter values: @Test void whenFooIsCalled_thenCounterIsIncremented() { fooService.foo(); fooService.foo(); fooService.foo(); MeterRegistryAssert.assertThat(meterRegistry) .counter(\"foo.count\") .hasCount(3); } Counters, Timers, Gauges will have different assertions available. For instance, when it comes to verifying Timers , we'll be able to check things like the mean() time, max() time, and so on: Navigating Through the API Looking at the Timer assertions example above, we'll notice there's no hasMeanTime() or hasMaxTime() method. This is intentional: hard-coded Duration values can lead to flaky tests: MeterRegistryAssert.assertThat(meterRegistry) .timer(\"foo\") .hasMeanTime(Duration.ofMillis(500)) // <-- this looks flaky! Instead of providing something like this, the API allows us to use mean() , which enables a large variety of Duration-specific assertions, such as isBetween() , isLessThan() , isGreaterThan() , isCloseTo() ...etc.: Other Meter Types For specialized meters like DistributionSummary or FunctionCounter , we can use the generic meter() API: @Test void shouldAssertOnMeasures() { DistributionSummary meter = DistributionSummary .builder(\"foo\") .register(simpleMeterRegistry); meter.record(10.0); meter.record(20.0); MeterRegistryAssert.assertThat(meterRegistry) .meter(\"foo\") .hasMeasurement(Statistic.COUNT, 2.0) .hasMeasurement(Statistic.TOTAL, 30.0) .hasMeasurement(Statistic.MAX, 20.0); } Conclusion I'm looking forward to seeing how the community uses these assertions and to contributing more to the Micrometer project in the future. You can check out the full pull request at github.com/micrometer-metrics/micrometer/pull/6870 . Big kudos to @shakuzen and @marcingrzejszczak for reviewing and guiding me through the contribution process!","title":"My First Contribution to Micrometer"},{"location":"blog/micrometer-assertions-contribution/#my-first-contribution-to-micrometer","text":"Published: January 13, 2026 #testing #oss #observability I'm excited to share that my first contribution to the Micrometer project has been merged and is now available in the 1.17.0-M1 pre-release ! The contribution adds AssertJ-style assertions for various meter types, making metric testing fun.","title":"My First Contribution to Micrometer"},{"location":"blog/micrometer-assertions-contribution/#testing-without-micrometer-test","text":"Recently, I wrote a Baeldung article on Testing with Micrometer , where we went over a few of the basics. Without Micrometer's test support module, we can rely on the MeterRegistry to fetch various meters and assert their values manually. For example, this is how we could verify that a counter has been incremented correctly: class MicrometerUnitTest { MeterRegistry meterRegistry = new SimpleMeterRegistry(); FooService fooService = new FooService(meterRegistry); @Test void whenFooIsCalled_thenCounterIsIncremented() { fooService.foo(); fooService.foo(); fooService.foo(); double invocations = meterRegistry.get(\"foo.count\") .counter() .count(); assertThat(invocations) .isEqualTo(3); } }","title":"Testing Without micrometer-test"},{"location":"blog/micrometer-assertions-contribution/#my-contribution-meter-assertions","text":"The good news is that Micrometer provides a dedicated test support module: <dependency> <groupId>io.micrometer</groupId> <artifactId>micrometer-test</artifactId> <version>1.17.0-M1</version> <scope>test</scope> </dependency> The micrometer-test was available for some time, but it was only covering a few basic assertions, such as checking the existence of a meter. With my contribution, we can now use the same fluent-api we know and love, for asserting meter values: @Test void whenFooIsCalled_thenCounterIsIncremented() { fooService.foo(); fooService.foo(); fooService.foo(); MeterRegistryAssert.assertThat(meterRegistry) .counter(\"foo.count\") .hasCount(3); } Counters, Timers, Gauges will have different assertions available. For instance, when it comes to verifying Timers , we'll be able to check things like the mean() time, max() time, and so on:","title":"My Contribution - Meter Assertions"},{"location":"blog/micrometer-assertions-contribution/#navigating-through-the-api","text":"Looking at the Timer assertions example above, we'll notice there's no hasMeanTime() or hasMaxTime() method. This is intentional: hard-coded Duration values can lead to flaky tests: MeterRegistryAssert.assertThat(meterRegistry) .timer(\"foo\") .hasMeanTime(Duration.ofMillis(500)) // <-- this looks flaky! Instead of providing something like this, the API allows us to use mean() , which enables a large variety of Duration-specific assertions, such as isBetween() , isLessThan() , isGreaterThan() , isCloseTo() ...etc.:","title":"Navigating Through the API"},{"location":"blog/micrometer-assertions-contribution/#other-meter-types","text":"For specialized meters like DistributionSummary or FunctionCounter , we can use the generic meter() API: @Test void shouldAssertOnMeasures() { DistributionSummary meter = DistributionSummary .builder(\"foo\") .register(simpleMeterRegistry); meter.record(10.0); meter.record(20.0); MeterRegistryAssert.assertThat(meterRegistry) .meter(\"foo\") .hasMeasurement(Statistic.COUNT, 2.0) .hasMeasurement(Statistic.TOTAL, 30.0) .hasMeasurement(Statistic.MAX, 20.0); }","title":"Other Meter Types"},{"location":"blog/micrometer-assertions-contribution/#conclusion","text":"I'm looking forward to seeing how the community uses these assertions and to contributing more to the Micrometer project in the future. You can check out the full pull request at github.com/micrometer-metrics/micrometer/pull/6870 . Big kudos to @shakuzen and @marcingrzejszczak for reviewing and guiding me through the contribution process!","title":"Conclusion"},{"location":"blog/tidy-first-commitments/","text":"'Tidy First?' and my Post-Reading Commitments Published: April 11, 2024 #design #books You know that good feeling when you come across a piece of code that's concise and cohesive? The code that allows you to focus on its purpose, and it doesn't have logic scattered all over the place? That's the same feeling I've got reading Kent Beck's \"Tidy First?\" . It's a remarkably succinct book, spanning just 100 pages, divided into three sections, each comprised of a handful of brief chapters. Some chapters are no longer than a single page, yet they're incredibly rich in content. At times, I found myself revisiting certain chapters to fully absorb their insights. Small Improvements with Big Impact The first section of the book explains what \"tidyings\" are, and provides some practical examples for 15 of these small improvements. In essence, we can think of \"tidyings\" as the younger relatives of \"refactorings\". Some tidyings can be as simple as extracting explanatory variables and helper functions. You'll probably be familiar with these techniques, and your IDE should already have shortcuts for pretty much all of them. However, reading through this section will give you a feeling of the size and granularity of these changes. This will help you better understand the second section about rhythm and pace. Long story short, the concept of \"refactoring\" got out of hand a bit, and we tend to commit big batches of structural changes and justify them as refactoring. By contrast, tidyings are small, incremental improvements that don't require a deep understanding of the codebase. Structural and Behavioral Changes In the second part of the book, Kent Beck discusses the two main types of software changes : those related to structure and those related to behavior . He emphasizes categorizing changes into these groups and advocates for separate pull requests for structural and behavioral modifications . While many technical books offer rigid sets of rules to adhere to, Tidy First? presents a set of questions and ideas that will serve as a guide to aid you in making the best decisions for your particular use case. For instance, the book doesn't provide a definitive answer regarding the timing of structural changes: Should they precede the implementation of the required feature? - Possible . Should we tidy the code after implementing a new feature? - Maybe . Should we tidy the code at all? - it depends . Changers and Observers \"Software design is an exercise in human relationships\" - Kent Beck The last section of the book delves into more theoretical concepts, like coupling and cohesion . Another interesting discussion in this section analyzes the two main attributes that make the software valuable: what it can do and what it can become . Needless to say, we'll use behavioral changes to define \"what software can do\", and structural changes to keep the options open for \"what it can become\". As a technical person, the importance of structural changes is obvious: they make future behavioral changes easy. However, these improvements may be less appealing to those unfamiliar with technical aspects. Kent Beck categorizes people into \"changers\" - developers who can modify the code, and \"observers\" - those who can only observe the system's behavior. He emphasizes that these two groups' ongoing collaboration and interaction leads to the eventual design of the system. My Commitments I like the way the book is written: it offers questions rather than rules. It made me think of my team and our projects. It made me question big batches of changes, regardless of their type. It made me commit that I will: Keep a short feedback loop : use more granular PRs, merge and release more often; Use different commits (at least) to separate behavioral and structural changes; Actively think about how each component can evolve; Always be aware of the impact of my changes: they should either immediately produce value (by increasing revenue or cutting costs), or keep the options open for the future.","title":"'Tidy First?' and my Post-Reading Commitments"},{"location":"blog/tidy-first-commitments/#tidy-first-and-my-post-reading-commitments","text":"Published: April 11, 2024 #design #books You know that good feeling when you come across a piece of code that's concise and cohesive? The code that allows you to focus on its purpose, and it doesn't have logic scattered all over the place? That's the same feeling I've got reading Kent Beck's \"Tidy First?\" . It's a remarkably succinct book, spanning just 100 pages, divided into three sections, each comprised of a handful of brief chapters. Some chapters are no longer than a single page, yet they're incredibly rich in content. At times, I found myself revisiting certain chapters to fully absorb their insights.","title":"'Tidy First?' and my Post-Reading Commitments"},{"location":"blog/tidy-first-commitments/#small-improvements-with-big-impact","text":"The first section of the book explains what \"tidyings\" are, and provides some practical examples for 15 of these small improvements. In essence, we can think of \"tidyings\" as the younger relatives of \"refactorings\". Some tidyings can be as simple as extracting explanatory variables and helper functions. You'll probably be familiar with these techniques, and your IDE should already have shortcuts for pretty much all of them. However, reading through this section will give you a feeling of the size and granularity of these changes. This will help you better understand the second section about rhythm and pace. Long story short, the concept of \"refactoring\" got out of hand a bit, and we tend to commit big batches of structural changes and justify them as refactoring. By contrast, tidyings are small, incremental improvements that don't require a deep understanding of the codebase.","title":"Small Improvements with Big Impact"},{"location":"blog/tidy-first-commitments/#structural-and-behavioral-changes","text":"In the second part of the book, Kent Beck discusses the two main types of software changes : those related to structure and those related to behavior . He emphasizes categorizing changes into these groups and advocates for separate pull requests for structural and behavioral modifications . While many technical books offer rigid sets of rules to adhere to, Tidy First? presents a set of questions and ideas that will serve as a guide to aid you in making the best decisions for your particular use case. For instance, the book doesn't provide a definitive answer regarding the timing of structural changes: Should they precede the implementation of the required feature? - Possible . Should we tidy the code after implementing a new feature? - Maybe . Should we tidy the code at all? - it depends .","title":"Structural and Behavioral Changes"},{"location":"blog/tidy-first-commitments/#changers-and-observers","text":"\"Software design is an exercise in human relationships\" - Kent Beck The last section of the book delves into more theoretical concepts, like coupling and cohesion . Another interesting discussion in this section analyzes the two main attributes that make the software valuable: what it can do and what it can become . Needless to say, we'll use behavioral changes to define \"what software can do\", and structural changes to keep the options open for \"what it can become\". As a technical person, the importance of structural changes is obvious: they make future behavioral changes easy. However, these improvements may be less appealing to those unfamiliar with technical aspects. Kent Beck categorizes people into \"changers\" - developers who can modify the code, and \"observers\" - those who can only observe the system's behavior. He emphasizes that these two groups' ongoing collaboration and interaction leads to the eventual design of the system.","title":"Changers and Observers"},{"location":"blog/tidy-first-commitments/#my-commitments","text":"I like the way the book is written: it offers questions rather than rules. It made me think of my team and our projects. It made me question big batches of changes, regardless of their type. It made me commit that I will: Keep a short feedback loop : use more granular PRs, merge and release more often; Use different commits (at least) to separate behavioral and structural changes; Actively think about how each component can evolve; Always be aware of the impact of my changes: they should either immediately produce value (by increasing revenue or cutting costs), or keep the options open for the future.","title":"My Commitments"}]}